<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/ab44ce7add5c3d11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab44ce7add5c3d11.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b597bb4f2a3f6d2e.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-e7a7892cb0edc024.js" defer=""></script><script src="/_next/static/chunks/pages/_app-44eef5cac14573bd.js" defer=""></script><script src="/_next/static/chunks/985-9c6dbc68fe2fe1fb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-306ce18f4b5f4cbd.js" defer=""></script><script src="/_next/static/E2gR3S07lyE-0abZ_pMFn/_buildManifest.js" defer=""></script><script src="/_next/static/E2gR3S07lyE-0abZ_pMFn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div>title: <!-- -->循环，还有这种操作！？——es6补充</div><div>date: <!-- -->2017-10-22</div><h1>循环，还有这种操作——es6补充！？</h1>
<p>缘，妙不可言——开始系统梳理es6后，发现关于循环的知识点又有了不少补充，正好填一下上次的坑嘛【抖】，本文有大量部分直接摘于<a href="http://es6.ruanyifeng.com/">es6标准入门</a></p>
<p>ps: <a href="http://b-sirius.me/2017/08/15/%E5%BE%AA%E7%8E%AF%EF%BC%8C%E8%BF%98%E6%9C%89%E8%BF%99%E7%A7%8D%E6%93%8D%E4%BD%9C/">上集回顾</a></p>
<hr/>
<h2>Object对象的拓展</h2>
<h3>Object.keys()</h3>
<p>其实是es5引入的方法，返回一个数组，常用于与for-of搭配遍历，成员是**参数对象自身（不含继承）<strong>的所有</strong>可枚举（enumerable）**属性的键名：</p>
<pre><code class="language-javascript">let obj = { foo: &#x27;bar&#x27;, baz: 42 }
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<p>相比之下，我们更熟悉的for-in遍历虽然同样是遍历<strong>可枚举属性</strong>的键名，但是它遍历的范围不只是对象自身，还有它的<strong>原型链</strong>，相比之下object.keys()在大多情况下更加适用。</p>
<p>另外，es2017中有一个提案，引入<strong>Object.values</strong>和<strong>Object.entires</strong>与其配套使用：</p>
<pre><code class="language-Javascript">let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]
}
</code></pre>
<h2>Iterator遍历器</h2>
<p>其实这才是重头戏啊，由于涉及到的点太多，只提及一点概念以及相关关键词。</p>
<h3>概念</h3>
<p>Iterator 的作用有三个：</p>
<ul>
<li>各种数据结构，提供一个统一的、简便的访问接口</li>
<li>使得数据结构的成员能够按某种次序排</li>
<li>ES6创造了一种新的遍历命令<code>for...of</code>循环，Iterator接口主要供<code>for...of</code>消费</li>
</ul>
<p>Iterator的遍历过程如下：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，<strong>遍历器对象本质上，就是一个指针对象</strong></li>
<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</li>
<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</li>
</ol>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是<strong>返回一个包含<code>value</code>和<code>done</code>两个属性的对象</strong>。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<p>模拟 next 方法返回值：</p>
<pre><code class="language-Javascript">var it = makeIterator([&#x27;a&#x27;, &#x27;b&#x27;]);

it.next() // { value: &quot;a&quot;, done: false }
it.next() // { value: &quot;b&quot;, done: false }
it.next() // { value: undefined, done: true }

function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex &lt; array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true};
    }
  };
}
</code></pre>
<h3>默认Iterator接口</h3>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，<strong>一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）</strong>。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历。</p>
<p>而原生具有该借口的数据结构如下：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>以数组为例：</p>
<pre><code class="language-Javascript">let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];
let iter = arr[Symbol.iterator]();

iter.next() // { value: &#x27;a&#x27;, done: false }
iter.next() // { value: &#x27;b&#x27;, done: false }
iter.next() // { value: &#x27;c&#x27;, done: false }
iter.next() // { value: undefined, done: true }
</code></pre>
<p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可），这个操作骚方法就太多了，还是详看es6吧，其中最值得注意的骚操作就是<strong>Generator函数</strong>。</p>
<h3>调用Iterator接口的场合</h3>
<ul>
<li>for-of循环</li>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield*</li>
</ul>
<hr/>
<p>没了？没了。Iterator涉及到的点和用法在es6入门中整理的很好了，继续复制粘贴感觉也没有太大意义嗯——</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"69","title":"循环，还有这种操作！？——es6补充","date":"2017-10-22","mdText":"\n# 循环，还有这种操作——es6补充！？\n\n缘，妙不可言——开始系统梳理es6后，发现关于循环的知识点又有了不少补充，正好填一下上次的坑嘛【抖】，本文有大量部分直接摘于[es6标准入门](http://es6.ruanyifeng.com/)\n\nps: [上集回顾](http://b-sirius.me/2017/08/15/%E5%BE%AA%E7%8E%AF%EF%BC%8C%E8%BF%98%E6%9C%89%E8%BF%99%E7%A7%8D%E6%93%8D%E4%BD%9C/)\n\n---\n\n## Object对象的拓展\n\n### Object.keys()\n\n其实是es5引入的方法，返回一个数组，常用于与for-of搭配遍历，成员是**参数对象自身（不含继承）**的所有**可枚举（enumerable）**属性的键名：\n\n```javascript\nlet obj = { foo: 'bar', baz: 42 }\nObject.keys(obj)\n// [\"foo\", \"baz\"]\n```\n\n相比之下，我们更熟悉的for-in遍历虽然同样是遍历**可枚举属性**的键名，但是它遍历的范围不只是对象自身，还有它的**原型链**，相比之下object.keys()在大多情况下更加适用。\n\n另外，es2017中有一个提案，引入**Object.values**和**Object.entires**与其配套使用：\n\n```Javascript\nlet {keys, values, entries} = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key of keys(obj)) {\n  console.log(key); // 'a', 'b', 'c'\n}\n\nfor (let value of values(obj)) {\n  console.log(value); // 1, 2, 3\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n}\n```\n\n## Iterator遍历器\n\n其实这才是重头戏啊，由于涉及到的点太多，只提及一点概念以及相关关键词。\n\n### 概念\n\nIterator 的作用有三个：\n\n* 各种数据结构，提供一个统一的、简便的访问接口\n* 使得数据结构的成员能够按某种次序排\n* ES6创造了一种新的遍历命令`for...of`循环，Iterator接口主要供`for...of`消费\n\nIterator的遍历过程如下：\n\n1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，**遍历器对象本质上，就是一个指针对象**\n2. 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员\n3. 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员\n4. 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置\n\n每一次调用`next`方法，都会返回数据结构的当前成员的信息。具体来说，就是**返回一个包含`value`和`done`两个属性的对象**。其中，`value`属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。\n\n模拟 next 方法返回值：\n\n``` Javascript\nvar it = makeIterator(['a', 'b']);\n\nit.next() // { value: \"a\", done: false }\nit.next() // { value: \"b\", done: false }\nit.next() // { value: undefined, done: true }\n\nfunction makeIterator(array) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex \u003c array.length ?\n        {value: array[nextIndex++], done: false} :\n        {value: undefined, done: true};\n    }\n  };\n}\n```\n\n### 默认Iterator接口\n\nES6 规定，默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，**一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）**。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历。\n\n而原生具有该借口的数据结构如下：\n\n- Array\n- Map\n- Set\n- String\n- TypedArray\n- 函数的 arguments 对象\n- NodeList 对象\n\n以数组为例：\n\n```Javascript\nlet arr = ['a', 'b', 'c'];\nlet iter = arr[Symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n```\n\n一个对象如果要具备可被`for...of`循环调用的 Iterator 接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法（原型链上的对象具有该方法也可），这个操作骚方法就太多了，还是详看es6吧，其中最值得注意的骚操作就是**Generator函数**。\n\n### 调用Iterator接口的场合\n\n* for-of循环\n* 解构赋值\n* 扩展运算符\n* yield*\n\n---\n\n没了？没了。Iterator涉及到的点和用法在es6入门中整理的很好了，继续复制粘贴感觉也没有太大意义嗯——\n\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"69"},"buildId":"E2gR3S07lyE-0abZ_pMFn","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>