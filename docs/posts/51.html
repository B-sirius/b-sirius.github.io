<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/ab44ce7add5c3d11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab44ce7add5c3d11.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-ed075df0e0b45174.js" defer=""></script><script src="/_next/static/chunks/main-e7a7892cb0edc024.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a336683ff51f334.js" defer=""></script><script src="/_next/static/chunks/985-9c6dbc68fe2fe1fb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-306ce18f4b5f4cbd.js" defer=""></script><script src="/_next/static/itz1UHKEJVpzrGA2oDCor/_buildManifest.js" defer=""></script><script src="/_next/static/itz1UHKEJVpzrGA2oDCor/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div>title: <!-- -->js对象克隆之谜</div><div>date: <!-- -->2017-08-26</div><h1>js对象克隆之谜</h1>
<h2>先谈谈深拷贝</h2>
<p>如何在js中获得一个克隆对象，可以说是喜闻乐见的话题了。相信大家都了解引用类型与基本类型，也都知道有种叫做深拷贝的东西，传说深拷贝可以获得一个克隆对象！那么像我这样的萌新自然就去学习了一波，我们能找到的代码基本都是这样的：</p>
<h3>低配版深拷贝</h3>
<pre><code class="language-javascript">var deepClone = function(currobj){
    if(typeof currobj !== &#x27;object&#x27;){
        return currobj;
    }
    if(currobj instanceof Array){
        var newobj = [];
    }else{
        var newobj = {}
    }
    for(var key in currobj){
        if(typeof currobj[key] !== &#x27;object&#x27;){
            newobj[key] = currobj[key];
        }else{
            newobj[key] = deepClone(currobj[key])    
        }
    }
    return newobj
}
</code></pre>
<p>啧啧真是很精巧啊！对于Array和普通Object都做了区分。但是显然，借助递归实现的深拷贝如果要克隆层级很多的复杂对象，容易造成内存溢出，咱可以做出一个小小改进：</p>
<h3>看起来酷一点的深拷贝</h3>
<pre><code class="language-javascript">var deepClone = function(currobj){
    if(typeof currobj !== &#x27;object&#x27;){
        return currobj;
    }
    if(currobj instanceof Array){
        var newobj = [];
    }else{
        var newobj = {}
    }
    var currQue = [currobj], newQue = [newobj]; //关键在这里
    while(currQue.length){
        var obj1 = currQue.shift(),obj2 = newQue.shift();
        for(var key in obj1){
            if(typeof obj1[key] !== &#x27;object&#x27;){
                obj2[key] = obj1[key];
            }else{
                if(obj1[key] instanceof Array ){
                    obj2[key] = [];
                }else{
                    obj2[key] = {}
                };
                // 妙啊
                currQue.push(obj1[key]);
                newQue.push(obj2[key]);
            }
        }
    }
    return newobj;
};
</code></pre>
<p>这里利用了两个队列，还算优雅的避免了递归的弊端。</p>
<h3>JSON序列化</h3>
<p>还有一种方法是利用JSON的内置方法，即所谓的JSON序列化：</p>
<pre><code class="language-javascript">var deepClone = function(obj){
    var str, newobj = obj.constructor === Array ? [] : {};
    if(typeof obj !== &#x27;object&#x27;){
        return;
    } else if(window.JSON){
        str = JSON.stringify(obj), //系列化对象
        newobj = JSON.parse(str); //还原
    } else {
        for(var i in obj){
            newobj[i] = typeof obj[i] === &#x27;object&#x27; ? 
            deepClone(obj[i]) : obj[i]; 
        }
    }
    return newobj;
};
</code></pre>
<p>不过不打紧，它与上面方法的效果基本相同。</p>
<h3>上面几种深拷贝的局限</h3>
<p>拜托，大家都很懂对象，上面的方法有几个很大的问题：</p>
<ul>
<li>遇到对象内部的<strong>循环引用</strong>直接gg</li>
<li>无法拷贝<strong>函数</strong>（typeof 函数 得到的是 &#x27;function&#x27;），函数仍是引用类型</li>
<li>无法正确保留<strong>实例对象的原型</strong></li>
</ul>
<p>于是，我们就要开始改造上面的深拷贝方法来进行完美的克隆了！.............么？</p>
<h2>等下，你到底要啥</h2>
<p>克隆克隆，我们平常把它挂在嘴上，但面对一个对象，我们真正想克隆的是什么？我想在99%的情况下，我们想克隆的是对象的<strong>数据</strong>，而保留它的<strong>原型引用</strong>和<strong>方法引用</strong>，因此上面提到的局限中的第二点，基本可以不考虑。现在咱再来看看怎么解决剩下两点。</p>
<h2>解决循环引用</h2>
<p>首先搞清什么是循环引用，常见的循环引用有两种：</p>
<h3>自身循环引用</h3>
<pre><code class="language-javascript">var a = {};
a._self = a;
</code></pre>
<p>这种循环引用可以说很是常见。</p>
<h3>多个对象互相引用</h3>
<pre><code class="language-javascript">var a = {};
var b = {};
a.brother = b;
b.brother = a;
</code></pre>
<p>也不是没见过，不过这是典型导致对象内存无法被回收的写法，本身就不推荐。</p>
<h3>解决之道</h3>
<p>目前只找到了针对第一种引用的解决方法，来自于Jquery源码：</p>
<pre><code class="language-javascript">jQuery.extend = jQuery.fn.extend = function() {
  // options是一个缓存变量，用来缓存arguments[i]
  // name是用来接收将要被扩展对象的key
  // src改变之前target对象上每个key对应的value
  // copy传入对象上每个key对应的valu
  // copyIsArray判定copy是否为一个数组
  // clone深拷贝中用来临时存对象或数组的src
  var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
  i = 1,
  length = arguments.length,
  deep = false;

  // 处理深拷贝的情况
  if (typeof target === &quot;boolean&quot;) {
    deep = target;
    target = arguments[1] || {};
    //跳过布尔值和目标 
    i++;
  }

  // 控制当target不是object或者function的情况
  if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) {
    target = {};
  }

  // 当参数列表长度等于i的时候，扩展jQuery对象自身
  if (length === i) {
    target = this; --i;
  }
  for (; i &lt; length; i++) {
    if ((options = arguments[i]) != null) {
      // 扩展基础对象
      for (name in options) {
        src = target[name];	
        copy = options[name];

        // 防止永无止境的循环，这里举个例子，如var i = {};i.a = i;$.extend(true,{},i);如果没有这个判断变成死循环了
        if (target === copy) {
          continue;
        }
        if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。
          } else {
            clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: {}; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。
          }
          // 递归拷贝
          target[name] = jQuery.extend(deep, clone, copy);
        } else if (copy !== undefined) {
          target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。
        }
      }
    }
  }
  // 返回修改的对象
  return target;
};
</code></pre>
<h2>解决原型的引用</h2>
<p>在我们想办法魔改深拷贝时，先看下以上这么多深拷贝的基本原理：</p>
<p><strong>利用for-in循环遍历对象属性，如果属性值是对象则深拷贝，不是则直接赋值</strong></p>
<p>于是俺眉头一皱发现事情并不简单，俺上一篇博客已经说明：<strong>for-in遍历的是对象以及其原型链上可枚举属性</strong>，因此想在遍历时对源对象的<code>__proto__</code>做手脚是根本不存在的，<strong><code>__proto__</code>以及它的不可枚举属性根本不会被遍历到</strong>。可以通过下面的例子看出：</p>
<pre><code class="language-javascript">var deepClone = function() {...} // 随便从上面拿一个
var A = function() {
  this.val = 1;
}
A.prototype.log = function() {
  console.log(this.val);
}

var obj1 = new A();
var obj2 = deepClone(obj1);

console.log(obj1); // A {val: 1}
console.log(obj2); // {val: 1, log: function(){...}}
</code></pre>
<p>因此，一个解决方法很单纯，就是像上面的jQuery.extend方法一样，<strong>自己传入拷贝的目标对象</strong>，extend方法本质上只是<strong>拓展目标对象的属性，使其获得源对象上的数据</strong>，这样一来只要我们先创建好符合需求的目标对象即可。</p>
<p>另一种方法则是不采用深拷贝，<strong>直接取出需要进行拷贝的对象的数据，然后再利用这份数据来实例化和设置一个新的对象出来</strong>：</p>
<pre><code class="language-javascript">var Foo = function( obj ){
    this.name = obj.name;
    this.sex = obj.sex
};

Foo.prototype.toJSON = funciton(){
    return { name: this.name, sex: this.sex };
};

var foo = new Foo({ name: &quot;bandit&quot;, sex: &quot;male&quot; });
var fooCopy = new Foo( foo.toJSON() );
</code></pre>
<p>问题同样得到解决【鼓掌】</p>
<hr/>
<p>回顾一下，没有哪种方法是万用的魔法 —— 在我们想要获得一个克隆对象之前，或许最好先搞清楚我们到底是在克隆什么，再采用最适合的方法。而非是拘泥于“深拷贝浅拷贝”的说法，去复制一段代码祈祷他能生效。我相信以上的示例代码还没有考虑到克隆对象的所有问题，但它们在合适的场景下能够处理合适的问题。嗯，其实很多事情都是这样蛤【带！】</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"51","title":"js对象克隆之谜","date":"2017-08-26","mdText":"\n# js对象克隆之谜\n\n## 先谈谈深拷贝\n\n如何在js中获得一个克隆对象，可以说是喜闻乐见的话题了。相信大家都了解引用类型与基本类型，也都知道有种叫做深拷贝的东西，传说深拷贝可以获得一个克隆对象！那么像我这样的萌新自然就去学习了一波，我们能找到的代码基本都是这样的：\n\n### 低配版深拷贝\n\n```javascript\nvar deepClone = function(currobj){\n    if(typeof currobj !== 'object'){\n        return currobj;\n    }\n    if(currobj instanceof Array){\n        var newobj = [];\n    }else{\n        var newobj = {}\n    }\n    for(var key in currobj){\n        if(typeof currobj[key] !== 'object'){\n            newobj[key] = currobj[key];\n        }else{\n            newobj[key] = deepClone(currobj[key])    \n        }\n    }\n    return newobj\n}\n```\n\n啧啧真是很精巧啊！对于Array和普通Object都做了区分。但是显然，借助递归实现的深拷贝如果要克隆层级很多的复杂对象，容易造成内存溢出，咱可以做出一个小小改进：\n\n### 看起来酷一点的深拷贝\n\n```javascript\nvar deepClone = function(currobj){\n    if(typeof currobj !== 'object'){\n        return currobj;\n    }\n    if(currobj instanceof Array){\n        var newobj = [];\n    }else{\n        var newobj = {}\n    }\n    var currQue = [currobj], newQue = [newobj]; //关键在这里\n    while(currQue.length){\n        var obj1 = currQue.shift(),obj2 = newQue.shift();\n        for(var key in obj1){\n            if(typeof obj1[key] !== 'object'){\n                obj2[key] = obj1[key];\n            }else{\n                if(obj1[key] instanceof Array ){\n                    obj2[key] = [];\n                }else{\n                    obj2[key] = {}\n                };\n                // 妙啊\n                currQue.push(obj1[key]);\n                newQue.push(obj2[key]);\n            }\n        }\n    }\n    return newobj;\n};\n```\n\n这里利用了两个队列，还算优雅的避免了递归的弊端。\n\n### JSON序列化\n\n还有一种方法是利用JSON的内置方法，即所谓的JSON序列化：\n\n```javascript\nvar deepClone = function(obj){\n    var str, newobj = obj.constructor === Array ? [] : {};\n    if(typeof obj !== 'object'){\n        return;\n    } else if(window.JSON){\n        str = JSON.stringify(obj), //系列化对象\n        newobj = JSON.parse(str); //还原\n    } else {\n        for(var i in obj){\n            newobj[i] = typeof obj[i] === 'object' ? \n            deepClone(obj[i]) : obj[i]; \n        }\n    }\n    return newobj;\n};\n```\n\n不过不打紧，它与上面方法的效果基本相同。\n\n### 上面几种深拷贝的局限\n\n拜托，大家都很懂对象，上面的方法有几个很大的问题：\n\n- 遇到对象内部的**循环引用**直接gg\n- 无法拷贝**函数**（typeof 函数 得到的是 'function'），函数仍是引用类型\n- 无法正确保留**实例对象的原型**\n\n于是，我们就要开始改造上面的深拷贝方法来进行完美的克隆了！.............么？\n\n## 等下，你到底要啥\n\n克隆克隆，我们平常把它挂在嘴上，但面对一个对象，我们真正想克隆的是什么？我想在99%的情况下，我们想克隆的是对象的**数据**，而保留它的**原型引用**和**方法引用**，因此上面提到的局限中的第二点，基本可以不考虑。现在咱再来看看怎么解决剩下两点。\n\n## 解决循环引用\n\n首先搞清什么是循环引用，常见的循环引用有两种：\n\n### 自身循环引用\n\n```javascript\nvar a = {};\na._self = a;\n```\n\n这种循环引用可以说很是常见。\n\n### 多个对象互相引用\n\n```javascript\nvar a = {};\nvar b = {};\na.brother = b;\nb.brother = a;\n```\n\n也不是没见过，不过这是典型导致对象内存无法被回收的写法，本身就不推荐。\n\n### 解决之道\n\n目前只找到了针对第一种引用的解决方法，来自于Jquery源码：\n\n```javascript\njQuery.extend = jQuery.fn.extend = function() {\n  // options是一个缓存变量，用来缓存arguments[i]\n  // name是用来接收将要被扩展对象的key\n  // src改变之前target对象上每个key对应的value\n  // copy传入对象上每个key对应的valu\n  // copyIsArray判定copy是否为一个数组\n  // clone深拷贝中用来临时存对象或数组的src\n  var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},\n  i = 1,\n  length = arguments.length,\n  deep = false;\n\n  // 处理深拷贝的情况\n  if (typeof target === \"boolean\") {\n    deep = target;\n    target = arguments[1] || {};\n    //跳过布尔值和目标 \n    i++;\n  }\n\n  // 控制当target不是object或者function的情况\n  if (typeof target !== \"object\" \u0026\u0026 !jQuery.isFunction(target)) {\n    target = {};\n  }\n\n  // 当参数列表长度等于i的时候，扩展jQuery对象自身\n  if (length === i) {\n    target = this; --i;\n  }\n  for (; i \u003c length; i++) {\n    if ((options = arguments[i]) != null) {\n      // 扩展基础对象\n      for (name in options) {\n        src = target[name];\t\n        copy = options[name];\n\n        // 防止永无止境的循环，这里举个例子，如var i = {};i.a = i;$.extend(true,{},i);如果没有这个判断变成死循环了\n        if (target === copy) {\n          continue;\n        }\n        if (deep \u0026\u0026 copy \u0026\u0026 (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n          if (copyIsArray) {\n            copyIsArray = false;\n            clone = src \u0026\u0026 jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。\n          } else {\n            clone = src \u0026\u0026 jQuery.isPlainObject(src) ? src: {}; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。\n          }\n          // 递归拷贝\n          target[name] = jQuery.extend(deep, clone, copy);\n        } else if (copy !== undefined) {\n          target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。\n        }\n      }\n    }\n  }\n  // 返回修改的对象\n  return target;\n};\n```\n\n## 解决原型的引用\n\n在我们想办法魔改深拷贝时，先看下以上这么多深拷贝的基本原理：\n\n**利用for-in循环遍历对象属性，如果属性值是对象则深拷贝，不是则直接赋值**\n\n于是俺眉头一皱发现事情并不简单，俺上一篇博客已经说明：**for-in遍历的是对象以及其原型链上可枚举属性**，因此想在遍历时对源对象的`__proto__`做手脚是根本不存在的，**`__proto__`以及它的不可枚举属性根本不会被遍历到**。可以通过下面的例子看出：\n\n```javascript\nvar deepClone = function() {...} // 随便从上面拿一个\nvar A = function() {\n  this.val = 1;\n}\nA.prototype.log = function() {\n  console.log(this.val);\n}\n\nvar obj1 = new A();\nvar obj2 = deepClone(obj1);\n\nconsole.log(obj1); // A {val: 1}\nconsole.log(obj2); // {val: 1, log: function(){...}}\n```\n\n因此，一个解决方法很单纯，就是像上面的jQuery.extend方法一样，**自己传入拷贝的目标对象**，extend方法本质上只是**拓展目标对象的属性，使其获得源对象上的数据**，这样一来只要我们先创建好符合需求的目标对象即可。\n\n另一种方法则是不采用深拷贝，**直接取出需要进行拷贝的对象的数据，然后再利用这份数据来实例化和设置一个新的对象出来**：\n\n```javascript\nvar Foo = function( obj ){\n    this.name = obj.name;\n    this.sex = obj.sex\n};\n\nFoo.prototype.toJSON = funciton(){\n    return { name: this.name, sex: this.sex };\n};\n\nvar foo = new Foo({ name: \"bandit\", sex: \"male\" });\nvar fooCopy = new Foo( foo.toJSON() );\n```\n\n问题同样得到解决【鼓掌】\n\n------\n\n回顾一下，没有哪种方法是万用的魔法 —— 在我们想要获得一个克隆对象之前，或许最好先搞清楚我们到底是在克隆什么，再采用最适合的方法。而非是拘泥于“深拷贝浅拷贝”的说法，去复制一段代码祈祷他能生效。我相信以上的示例代码还没有考虑到克隆对象的所有问题，但它们在合适的场景下能够处理合适的问题。嗯，其实很多事情都是这样蛤【带！】"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"51"},"buildId":"itz1UHKEJVpzrGA2oDCor","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>