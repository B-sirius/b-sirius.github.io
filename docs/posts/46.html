<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/ab44ce7add5c3d11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab44ce7add5c3d11.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b597bb4f2a3f6d2e.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-e7a7892cb0edc024.js" defer=""></script><script src="/_next/static/chunks/pages/_app-44eef5cac14573bd.js" defer=""></script><script src="/_next/static/chunks/985-9c6dbc68fe2fe1fb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-306ce18f4b5f4cbd.js" defer=""></script><script src="/_next/static/E2gR3S07lyE-0abZ_pMFn/_buildManifest.js" defer=""></script><script src="/_next/static/E2gR3S07lyE-0abZ_pMFn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div>title: <!-- -->循环，还有这种操作！？</div><div>date: <!-- -->2017-08-15</div><h1>循环，还有这种操作！？</h1>
<p>虽说已经看了n遍相关博文，但在实际操作中各种循环的操作实在是令人摸不着头脑，系统整理一回【拍桌】</p>
<h2>简单 for 循环</h2>
<p>简单 for 循环一般只适用于数组，最为常见的一种写法：</p>
<pre><code class="language-javascript">var arr = [1, 2, 3];
for (var i = 0, len = arr.length; i &lt; len; i++) {...}
</code></pre>
<p>在数组长度不变时，用<code>len</code>保存数组长度进行循环效率更佳。</p>
<p>另外，如需在遍历中进行改变长度的删除操作，一般采用倒序遍历：</p>
<pre><code class="language-javascript">var arr = [1, 2, 3];
for (var i = arr.length - 1; i &gt;= 0; i--) {
  if (arr[i] === 1)
    arr.splice(i, 1);
}
console.log(arr); // [2, 3]
</code></pre>
<h2>for-in 循环</h2>
<h3>语法</h3>
<pre><code class="language-javascript">for (key in object) {...}
</code></pre>
<h3>参数</h3>
<p><code>key</code>：每次迭代时，将不同的属性名分配给变量</p>
<p><code>object</code>：被迭代枚举其属性的对象</p>
<h3>适用情况</h3>
<p>首先咱的确可以用 for-in 来遍历数组</p>
<pre><code class="language-javascript">var arr = [1, 2, 3];
for (index in arr) {
  console.log(`arr[${index}]: ${arr[index]}`);
} 
// chrome中的输出结果
// arr[0]: 1
// arr[1]: 2
// arr[2]: 3
</code></pre>
<p>但是注意，<strong>for-in</strong> 遍历的是 <strong>对象以及其原型链上可枚举属性(<code>String</code>)，而不是数组的索引(<code>Number</code>)，且迭代顺序依赖于执行环境，并不一定按某种顺序访问元素</strong>，数组在js中也是一个对象，属性<strong>并非是<code>Number</code>类型而是<code>String</code>类型</strong>。<code>length</code>属性值未被遍历也只是因为它不是可枚举属性。</p>
<p>因此我们做出一点魔改：</p>
<pre><code class="language-javascript">var arr = [1, 2, 3];
arr.arrFeeling = &#x27;fucked up&#x27;;
Array.prototype.arrayFeeling = &#x27;thats good&#x27;;
Object.prototype.objFeeling = &#x27;emmmmm&#x27;;
for (key in arr) {
  console.log(`${key + 1}: ${arr[key]}`);
} 
// chrome中的输出结果
// 01: 1
// 11: 2
// 21: 3
// arrFeeling1: fucked up
// arrayFeeling1: thats good
// objFeeling1: emmmmm
</code></pre>
<p>可以看出，这里的结果已经他喵的和我们预想的数组遍历差了很多很多【震惊】，因此从某种意义上讲， for-in 遍历的初衷是遍历对象中的属性，传统的数组遍历并不适合用for-in。</p>
<p>但是也正得益于这个特性，for-in遍历可用于遍历<strong>稀疏数组</strong>：</p>
<pre><code class="language-javascript">var arr = [];
arr[999] = 1;
for (key in arr) {
  console.log(`${key}: ${arr[key]}`);
} 
// chrome中的输出
// 999: 1
</code></pre>
<p>此处的 <code>arr.length</code> 为1000，如果用简单for循环来输出，会遍历1000次（输出999个<code>undefined</code>），而使用for-in只会遍历一次。如果担心输出原型链上的属性，可以利用<code>hasOwnProperty</code>方法。</p>
<h2>forEach</h2>
<p>简单的例子：</p>
<pre><code class="language-javascript">var arr = [null, 2, 3];
arr[5] = 5;
arr[&#x27;die&#x27;] = &#x27;die!&#x27; // 不会被遍历到
arr.forEach(function(data) {
    console.log(data);
});
// null
// 2
// 3
// 5
</code></pre>
<p>forEach 是Array的方法，会为数组中含<strong>有效值（也就是说，会跳过数组空位)</strong>(<strong>包括值为null</strong>)的每一<strong>索引项</strong>执行一次传入的回调函数。回调函数会被依次传入三个参数：</p>
<ul>
<li>数组当前项的值</li>
<li>数组当前项的索引（<strong>Number类型！</strong>）</li>
<li>数组对象本身</li>
</ul>
<p>需要注意的是，forEach 不会在迭代前创建数组的副本，因此<strong>可以改变原数组</strong>，若迭代时数组长度改变：</p>
<pre><code class="language-javascript">var words = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];
words.forEach(function(word) {
  console.log(word);
  if (word === &quot;two&quot;) {
    words.shift();
  }
});
// one
// two
// four
</code></pre>
<p>forEach 的一大缺点：<strong>一旦开始就无法跳出</strong>，因此ES5中提供了一些其他类似的方法：</p>
<ul>
<li>every:测试数组的所有元素是否都通过了指定函数的测试， 循环在第一次 return false 后返回，<strong>不会改变原数组</strong></li>
<li>some: 测试数组中的某些元素是否通过由提供的函数实现的测试，循环在第一次 return true 后返回，<strong>不会改变原数组</strong></li>
<li>filter: 返回一个新的数组，其包含通过所提供函数实现的测试的所有元素，<strong>不会改变原数组</strong></li>
<li>map: 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，<strong>不会改变原数组</strong></li>
<li>reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果，<strong>啊——不会改变原数组</strong></li>
</ul>
<h2>for-of</h2>
<p>简单的例子：</p>
<pre><code class="language-javascript">var arr = [1, 2, 3];
for (let val of arr) {
	console.log(val);
}
// 1
// 2
// 3
</code></pre>
<p>for-of 乍看之下和forEach的功能好像重叠了，但是作为ES6新支持的语法，自然有一些优点：</p>
<ul>
<li>作为正经的 for 循环语法，可以正常的 break，continue，return</li>
<li>for-of 循环并非数组专用，它支持<strong>可迭代对象</strong>，包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Map"><code>Map</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments">arguments</a> 对象等等，注意不包括<strong>Object</strong>对象，如果你想迭代Object对象，for-in循环更加适合</li>
<li>搭配ES6新增的用户自定义迭代器（说的那么模糊，因为我还不是很懂）</li>
</ul>
<p>此外，for-of与上面一大串forEach, map等有一个很大的区别：<strong>不会跳过数组空位</strong>:</p>
<pre><code class="language-javascript">let arr = [&#x27;holy&#x27;, &#x27;shit&#x27;];
arr.forEach(x =&gt; console.log(x));
// holy
// shit
for (let x of arr) {
	console.log(x);
}
// holy
// undefined
// shit
</code></pre>
<hr/>
<p>最后回头看一下，循环遍历这个操作其实需要考虑很多：</p>
<ul>
<li>遍历方法所适用的对象</li>
<li>是否会创建原对象副本（改变原对象）</li>
<li>遍历时会传入的参数（<code>undefined</code>，原型链）以及参数类型（<code>Number</code>, <code>String</code>）</li>
<li>如何处理空值</li>
<li>...</li>
</ul>
<p>因此弄清楚他们之间的分别还是有必要的吧科科。ES6还添加了个叫<strong>iterable</strong>的玩意儿，也与迭代密切相关，不是很懂先坑了【逃】</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"46","title":"循环，还有这种操作！？","date":"2017-08-15","mdText":"\n# 循环，还有这种操作！？\n\n虽说已经看了n遍相关博文，但在实际操作中各种循环的操作实在是令人摸不着头脑，系统整理一回【拍桌】\n\n## 简单 for 循环\n\n简单 for 循环一般只适用于数组，最为常见的一种写法：\n\n```javascript\nvar arr = [1, 2, 3];\nfor (var i = 0, len = arr.length; i \u003c len; i++) {...}\n```\n\n在数组长度不变时，用`len`保存数组长度进行循环效率更佳。\n\n另外，如需在遍历中进行改变长度的删除操作，一般采用倒序遍历：\n\n```javascript\nvar arr = [1, 2, 3];\nfor (var i = arr.length - 1; i \u003e= 0; i--) {\n  if (arr[i] === 1)\n    arr.splice(i, 1);\n}\nconsole.log(arr); // [2, 3]\n```\n\n## for-in 循环\n\n### 语法\n\n```javascript\nfor (key in object) {...}\n```\n\n### 参数\n\n`key`：每次迭代时，将不同的属性名分配给变量\n\n`object`：被迭代枚举其属性的对象\n\n### 适用情况\n\n首先咱的确可以用 for-in 来遍历数组\n\n```javascript\nvar arr = [1, 2, 3];\nfor (index in arr) {\n  console.log(`arr[${index}]: ${arr[index]}`);\n} \n// chrome中的输出结果\n// arr[0]: 1\n// arr[1]: 2\n// arr[2]: 3\n```\n\n但是注意，**for-in** 遍历的是 **对象以及其原型链上可枚举属性(`String`)，而不是数组的索引(`Number`)，且迭代顺序依赖于执行环境，并不一定按某种顺序访问元素**，数组在js中也是一个对象，属性**并非是`Number`类型而是`String`类型**。`length`属性值未被遍历也只是因为它不是可枚举属性。\n\n因此我们做出一点魔改：\n\n```javascript\nvar arr = [1, 2, 3];\narr.arrFeeling = 'fucked up';\nArray.prototype.arrayFeeling = 'thats good';\nObject.prototype.objFeeling = 'emmmmm';\nfor (key in arr) {\n  console.log(`${key + 1}: ${arr[key]}`);\n} \n// chrome中的输出结果\n// 01: 1\n// 11: 2\n// 21: 3\n// arrFeeling1: fucked up\n// arrayFeeling1: thats good\n// objFeeling1: emmmmm\n```\n\n可以看出，这里的结果已经他喵的和我们预想的数组遍历差了很多很多【震惊】，因此从某种意义上讲， for-in 遍历的初衷是遍历对象中的属性，传统的数组遍历并不适合用for-in。\n\n但是也正得益于这个特性，for-in遍历可用于遍历**稀疏数组**：\n\n```javascript\nvar arr = [];\narr[999] = 1;\nfor (key in arr) {\n  console.log(`${key}: ${arr[key]}`);\n} \n// chrome中的输出\n// 999: 1\n```\n\n此处的 `arr.length` 为1000，如果用简单for循环来输出，会遍历1000次（输出999个`undefined`），而使用for-in只会遍历一次。如果担心输出原型链上的属性，可以利用`hasOwnProperty`方法。\n\n## forEach\n\n简单的例子：\n\n```javascript\nvar arr = [null, 2, 3];\narr[5] = 5;\narr['die'] = 'die!' // 不会被遍历到\narr.forEach(function(data) {\n    console.log(data);\n});\n// null\n// 2\n// 3\n// 5\n```\n\nforEach 是Array的方法，会为数组中含**有效值（也就是说，会跳过数组空位)**(**包括值为null**)的每一**索引项**执行一次传入的回调函数。回调函数会被依次传入三个参数：\n\n- 数组当前项的值\n- 数组当前项的索引（**Number类型！**）\n- 数组对象本身\n\n需要注意的是，forEach 不会在迭代前创建数组的副本，因此**可以改变原数组**，若迭代时数组长度改变：\n\n```javascript\nvar words = [\"one\", \"two\", \"three\", \"four\"];\nwords.forEach(function(word) {\n  console.log(word);\n  if (word === \"two\") {\n    words.shift();\n  }\n});\n// one\n// two\n// four\n```\n\nforEach 的一大缺点：**一旦开始就无法跳出**，因此ES5中提供了一些其他类似的方法：\n\n- every:测试数组的所有元素是否都通过了指定函数的测试， 循环在第一次 return false 后返回，**不会改变原数组**\n- some: 测试数组中的某些元素是否通过由提供的函数实现的测试，循环在第一次 return true 后返回，**不会改变原数组**\n- filter: 返回一个新的数组，其包含通过所提供函数实现的测试的所有元素，**不会改变原数组**\n- map: 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，**不会改变原数组**\n- reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果，**啊——不会改变原数组**\n\n## for-of\n\n简单的例子：\n\n```javascript\nvar arr = [1, 2, 3];\nfor (let val of arr) {\n\tconsole.log(val);\n}\n// 1\n// 2\n// 3\n```\n\nfor-of 乍看之下和forEach的功能好像重叠了，但是作为ES6新支持的语法，自然有一些优点：\n\n- 作为正经的 for 循环语法，可以正常的 break，continue，return\n- for-of 循环并非数组专用，它支持**可迭代对象**，包括 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array), [`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Map), [`Set`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set), [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String), [`TypedArray`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)，[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments) 对象等等，注意不包括**Object**对象，如果你想迭代Object对象，for-in循环更加适合\n- 搭配ES6新增的用户自定义迭代器（说的那么模糊，因为我还不是很懂）\n\n此外，for-of与上面一大串forEach, map等有一个很大的区别：**不会跳过数组空位**:\n\n```javascript\nlet arr = ['holy', 'shit'];\narr.forEach(x =\u003e console.log(x));\n// holy\n// shit\nfor (let x of arr) {\n\tconsole.log(x);\n}\n// holy\n// undefined\n// shit\n```\n\n\n\n------\n\n最后回头看一下，循环遍历这个操作其实需要考虑很多：\n\n- 遍历方法所适用的对象\n- 是否会创建原对象副本（改变原对象）\n- 遍历时会传入的参数（`undefined`，原型链）以及参数类型（`Number`, `String`）\n- 如何处理空值\n- ...\n\n因此弄清楚他们之间的分别还是有必要的吧科科。ES6还添加了个叫**iterable**的玩意儿，也与迭代密切相关，不是很懂先坑了【逃】"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"46"},"buildId":"E2gR3S07lyE-0abZ_pMFn","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>