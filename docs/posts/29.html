<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/ab44ce7add5c3d11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab44ce7add5c3d11.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b597bb4f2a3f6d2e.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-e7a7892cb0edc024.js" defer=""></script><script src="/_next/static/chunks/pages/_app-44eef5cac14573bd.js" defer=""></script><script src="/_next/static/chunks/985-9c6dbc68fe2fe1fb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-306ce18f4b5f4cbd.js" defer=""></script><script src="/_next/static/xVFKlOnB1qu1k0-FevYPk/_buildManifest.js" defer=""></script><script src="/_next/static/xVFKlOnB1qu1k0-FevYPk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div>title: <!-- -->当我们讨论动画时，我们在讨论什么———color篇</div><div>date: <!-- -->2017-04-30</div><h1>当我们讨论动画时，我们在讨论什么———color篇</h1>
<h2>设计模式的运用</h2>
<p>除了上篇的transform动画需要特殊处理，还有一个大头就是属性值为颜色的处理。不同于transform，属性值为颜色的属性可以有很多种，而颜色属性值又有rgb、hsl、rgba甚至十六进制等多种表示方式，意味着两者对属性名、属性值分离的逻辑也是不同的，再加上对普通属性处理的逻辑，至少有三种不同的分离逻辑。因此在加入颜色的处理方法之前，我先用策略模式重构了这部分逻辑，最后结果如下：</p>
<pre><code class="language-javascript">/**
 * 对porps属性值处理，获得渲染时所需的数据
 */
Rush.prototype._handleProps = (function() {
    // transform 的属性需要特别处理
    const transformProperties = [&quot;translateX&quot;, &quot;translateY&quot;, &quot;translateZ&quot;, &quot;scale&quot;, &quot;scaleX&quot;, &quot;scaleY&quot;, &quot;scaleZ&quot;, &quot;skewX&quot;, &quot;skewY&quot;, &quot;rotateX&quot;, &quot;rotateY&quot;, &quot;rotateZ&quot;];

    // color 的属性需要特别处理
    const colorProperties = [&quot;color&quot;, &quot;background-color&quot;, &quot;border-color&quot;, &quot;outline-color&quot;];

    var propertyHandler = {};

    // 普通属性的处理方法
    propertyHandler[&#x27;default&#x27;] = function(task, key) {
        var el = this.el;

        var begin; // 初始属性值和单位
        var end = propertyValueHandler(key, task.props[key]); // 末属性数值和单位

        var realPropertyName = key; // 真正的属性名
        var styleLogic = &#x27;default&#x27;;

        var beginValue = getComputedStyle(el, null).getPropertyValue(realPropertyName); // 获得初始属性值(带单位)

        begin = propertyValueHandler(key, beginValue); // 获得属性数值和单位

        realPropertyName = transferStyleName(realPropertyName); // 将连字符格式转换为驼峰式

        // 为task新增属性
        task.newProps[key] = {
            begin,
            end,
            realPropertyName,
            styleLogic
        }
    }

    // transform属性的处理方法
    for (var propertyName of transformProperties) {
        propertyHandler[propertyName] = function(task, key) {
            var el = this.el;

            var begin; // 初始属性值和单位
            var end = propertyValueHandler(key, task.props[key]); // 末属性数值和单位

            var realPropertyName = &#x27;transform&#x27;;
            var styleLogic = &#x27;transform&#x27;;

            var beginValue; // 初始属性值（带单位）

            // 如果已经缓存了transform属性
            if (el.transformCache) {
                if (el.transformCache[key]) {
                    beginValue = el.transformCache[key].value;
                } else {
                    beginValue = 0;
                    el.transformCache[key] = {
                        value: beginValue,
                        unitType: end.unitType
                    };
                }
            } else {
                // 只有在元素没有在style中定义任何transform属性时才会调用
                beginValue = 0;

                // 给这个元素添加transfromCache属性，用于保存transfrom的各个属性
                // 因为如果style中的transform被设置了多个值，读取到的将是&quot;rotate(30deg) translateX(10px)&quot;这样的值，将无法处理
                el.transformCache = {};
                el.transformCache[key] = {
                    value: beginValue,
                    unitType: end.unitType
                };
            }

            begin = propertyValueHandler(key, beginValue); // 获得属性数值和单位

            // 为task新增属性
            task.newProps[key] = {
                begin,
                end,
                realPropertyName,
                styleLogic
            }
        }
    }

    // color属性的处理方法，统一转换为rgba来处理
    for (var propertyName of colorProperties) {
        propertyHandler[propertyName] = function(task, key) {
            var el = this.el;

            var begin;
            var end = normalize2rgba(task.props[key]);

            var realPropertyName = key;

            var beginValue = getComputedStyle(el, null).getPropertyValue(realPropertyName); // e.g. rgba(255, 255, 255, 1);
            begin = normalize2rgba(beginValue); // 返回的是转换后的rgba对象

            var styleLogic = &#x27;rgba&#x27;;

            realPropertyName = transferStyleName(realPropertyName); // 将连字符格式转换为驼峰式


            task.newProps[key] = {
                begin,
                end,
                realPropertyName,
                styleLogic
            }
        }
    }

    return function(task) {
        var el = this.el;

        task.newProps = {}; // 保存渲染动画时所需的数据

        for (var key in task.props) {
            if (propertyHandler[key]) { // 特殊属性
                propertyHandler[key].call(this, task, key);
            } else { // 普通属性
                propertyHandler[&#x27;default&#x27;].call(this, task, key);
            }
        }
    }
})();
</code></pre>
<h2>color的痛点</h2>
<ul>
<li>
<p>color的多种属性值</p>
<p>属性值可能是rgb色，hsl色，rgba色甚至16进制色，为他们各做一种处理逻辑显然太过复杂且没有必要，将其全部转换成同一单位再进行处理更加明智。考虑到透明度，我觉得全部转换为rgba最为合适。颜色转换的逻辑到处都能找到就不细说了。</p>
</li>
<li>
<p>rgba属性值的分离</p>
<p>不同于之前所有的属性值，rgba值有4个数值，考虑到我们的缓动函数每次只处理一个数值，需要用数组保存再进行分别处理</p>
<pre><code class="language-javascript">for (var key in task.newProps) {
            if (typeof task.newProps[key].begin.num !== &#x27;number&#x27;) {
                var beginArr = task.newProps[key].begin.num;
                var endArr = task.newProps[key].end.num;

                var newArr = [];
                for (var i = 0; i &lt; beginArr.length; i++) {
                    var beginValue = beginArr[i],
                        changeValue = endArr[i] - beginValue,
                        newValue = easing(currTime, beginValue, changeValue, duration); // 根据缓动函数计算新的位置
                        newArr.push(newValue);
                };

                self.styleHandler(task, key, newArr);
            } else {
                var beginValue = task.newProps[key].begin.num, // 初始位置
                    changeValue = task.newProps[key].end.num - beginValue; // 位置改变量

                var newValue = easing(currTime, beginValue, changeValue, duration); // 根据缓动函数计算新的位置

                // 更新style
                self.styleHandler(task, key, newValue);
            }
        }
</code></pre>
</li>
<li>
<p>将处理后得到的新属性重新拼接为style样式</p>
<p>同样是采取策略模式，为不同的拼接逻辑定义了对应的拼接方法</p>
<pre><code class="language-javascript">Rush.prototype.styleHandler = (function() {
    var t = {
        &#x27;transform&#x27;: function(task, key, newValue) {
            this.el.transformCache[key].value = newValue; // 更新缓存值

            var propertyValue = &#x27;&#x27;,
                propertyName = task.newProps[key].realPropertyName;

            // e.g transform: rotateZ(100deg) translateX(50px)
            for (var key in this.el.transformCache) {
                var name = key, // e.g rotateZ
                    val = this.el.transformCache[key].value, // e.g 100
                    unitType = this.el.transformCache[key].unitType; // e.g deg

                propertyValue += `${name}(${val}${unitType})`; // e.g rotate(100deg)
            }

            this.el.style[propertyName] = propertyValue;
        },

        &#x27;rgba&#x27;: function(task, key, newArr) {
            var text = &#x27;rgba(&#x27;;

            for (var i = 0; i &lt; newArr.length - 1; i++) {
                text += (newArr[i]).toFixed() + &#x27;, &#x27;;
            }
            text += newArr[newArr.length - 1].toFixed(2) + &#x27;)&#x27;;

            this.el.style[task.newProps[key].realPropertyName] = text;
        },

        &#x27;default&#x27;: function(task, key, newValue) {
            this.el.style[task.newProps[key].realPropertyName] = `${newValue}${task.newProps[key].end.unitType}`;
        }
    };

    return function(task, key, newValue) {
        var styleLogic = task.newProps[key].styleLogic;

        t[styleLogic].call(this, task, key, newValue);
    };
})();
</code></pre>
</li>
</ul>
<hr/>
<p>至此，通用js动画库的两大难点基本得到解决，虽说是针对transform和color的处理方法，但在编码过程中，如何运用设计模式优化代码结构可能花费了更多的时间。</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"29","title":"当我们讨论动画时，我们在讨论什么———color篇","date":"2017-04-30","mdText":"\n# 当我们讨论动画时，我们在讨论什么———color篇\n\n## 设计模式的运用\n\n除了上篇的transform动画需要特殊处理，还有一个大头就是属性值为颜色的处理。不同于transform，属性值为颜色的属性可以有很多种，而颜色属性值又有rgb、hsl、rgba甚至十六进制等多种表示方式，意味着两者对属性名、属性值分离的逻辑也是不同的，再加上对普通属性处理的逻辑，至少有三种不同的分离逻辑。因此在加入颜色的处理方法之前，我先用策略模式重构了这部分逻辑，最后结果如下：\n\n```javascript\n/**\n * 对porps属性值处理，获得渲染时所需的数据\n */\nRush.prototype._handleProps = (function() {\n    // transform 的属性需要特别处理\n    const transformProperties = [\"translateX\", \"translateY\", \"translateZ\", \"scale\", \"scaleX\", \"scaleY\", \"scaleZ\", \"skewX\", \"skewY\", \"rotateX\", \"rotateY\", \"rotateZ\"];\n\n    // color 的属性需要特别处理\n    const colorProperties = [\"color\", \"background-color\", \"border-color\", \"outline-color\"];\n\n    var propertyHandler = {};\n\n    // 普通属性的处理方法\n    propertyHandler['default'] = function(task, key) {\n        var el = this.el;\n\n        var begin; // 初始属性值和单位\n        var end = propertyValueHandler(key, task.props[key]); // 末属性数值和单位\n\n        var realPropertyName = key; // 真正的属性名\n        var styleLogic = 'default';\n\n        var beginValue = getComputedStyle(el, null).getPropertyValue(realPropertyName); // 获得初始属性值(带单位)\n\n        begin = propertyValueHandler(key, beginValue); // 获得属性数值和单位\n\n        realPropertyName = transferStyleName(realPropertyName); // 将连字符格式转换为驼峰式\n\n        // 为task新增属性\n        task.newProps[key] = {\n            begin,\n            end,\n            realPropertyName,\n            styleLogic\n        }\n    }\n\n    // transform属性的处理方法\n    for (var propertyName of transformProperties) {\n        propertyHandler[propertyName] = function(task, key) {\n            var el = this.el;\n\n            var begin; // 初始属性值和单位\n            var end = propertyValueHandler(key, task.props[key]); // 末属性数值和单位\n\n            var realPropertyName = 'transform';\n            var styleLogic = 'transform';\n\n            var beginValue; // 初始属性值（带单位）\n\n            // 如果已经缓存了transform属性\n            if (el.transformCache) {\n                if (el.transformCache[key]) {\n                    beginValue = el.transformCache[key].value;\n                } else {\n                    beginValue = 0;\n                    el.transformCache[key] = {\n                        value: beginValue,\n                        unitType: end.unitType\n                    };\n                }\n            } else {\n                // 只有在元素没有在style中定义任何transform属性时才会调用\n                beginValue = 0;\n\n                // 给这个元素添加transfromCache属性，用于保存transfrom的各个属性\n                // 因为如果style中的transform被设置了多个值，读取到的将是\"rotate(30deg) translateX(10px)\"这样的值，将无法处理\n                el.transformCache = {};\n                el.transformCache[key] = {\n                    value: beginValue,\n                    unitType: end.unitType\n                };\n            }\n\n            begin = propertyValueHandler(key, beginValue); // 获得属性数值和单位\n\n            // 为task新增属性\n            task.newProps[key] = {\n                begin,\n                end,\n                realPropertyName,\n                styleLogic\n            }\n        }\n    }\n\n    // color属性的处理方法，统一转换为rgba来处理\n    for (var propertyName of colorProperties) {\n        propertyHandler[propertyName] = function(task, key) {\n            var el = this.el;\n\n            var begin;\n            var end = normalize2rgba(task.props[key]);\n\n            var realPropertyName = key;\n\n            var beginValue = getComputedStyle(el, null).getPropertyValue(realPropertyName); // e.g. rgba(255, 255, 255, 1);\n            begin = normalize2rgba(beginValue); // 返回的是转换后的rgba对象\n\n            var styleLogic = 'rgba';\n\n            realPropertyName = transferStyleName(realPropertyName); // 将连字符格式转换为驼峰式\n\n\n            task.newProps[key] = {\n                begin,\n                end,\n                realPropertyName,\n                styleLogic\n            }\n        }\n    }\n\n    return function(task) {\n        var el = this.el;\n\n        task.newProps = {}; // 保存渲染动画时所需的数据\n\n        for (var key in task.props) {\n            if (propertyHandler[key]) { // 特殊属性\n                propertyHandler[key].call(this, task, key);\n            } else { // 普通属性\n                propertyHandler['default'].call(this, task, key);\n            }\n        }\n    }\n})();\n```\n\n## color的痛点\n\n- color的多种属性值\n\n  属性值可能是rgb色，hsl色，rgba色甚至16进制色，为他们各做一种处理逻辑显然太过复杂且没有必要，将其全部转换成同一单位再进行处理更加明智。考虑到透明度，我觉得全部转换为rgba最为合适。颜色转换的逻辑到处都能找到就不细说了。\n\n- rgba属性值的分离\n\n  不同于之前所有的属性值，rgba值有4个数值，考虑到我们的缓动函数每次只处理一个数值，需要用数组保存再进行分别处理\n\n  ```javascript\n  for (var key in task.newProps) {\n              if (typeof task.newProps[key].begin.num !== 'number') {\n                  var beginArr = task.newProps[key].begin.num;\n                  var endArr = task.newProps[key].end.num;\n\n                  var newArr = [];\n                  for (var i = 0; i \u003c beginArr.length; i++) {\n                      var beginValue = beginArr[i],\n                          changeValue = endArr[i] - beginValue,\n                          newValue = easing(currTime, beginValue, changeValue, duration); // 根据缓动函数计算新的位置\n                          newArr.push(newValue);\n                  };\n\n                  self.styleHandler(task, key, newArr);\n              } else {\n                  var beginValue = task.newProps[key].begin.num, // 初始位置\n                      changeValue = task.newProps[key].end.num - beginValue; // 位置改变量\n\n                  var newValue = easing(currTime, beginValue, changeValue, duration); // 根据缓动函数计算新的位置\n\n                  // 更新style\n                  self.styleHandler(task, key, newValue);\n              }\n          }\n  ```\n\n- 将处理后得到的新属性重新拼接为style样式\n\n  同样是采取策略模式，为不同的拼接逻辑定义了对应的拼接方法\n\n  ```javascript\n  Rush.prototype.styleHandler = (function() {\n      var t = {\n          'transform': function(task, key, newValue) {\n              this.el.transformCache[key].value = newValue; // 更新缓存值\n\n              var propertyValue = '',\n                  propertyName = task.newProps[key].realPropertyName;\n\n              // e.g transform: rotateZ(100deg) translateX(50px)\n              for (var key in this.el.transformCache) {\n                  var name = key, // e.g rotateZ\n                      val = this.el.transformCache[key].value, // e.g 100\n                      unitType = this.el.transformCache[key].unitType; // e.g deg\n\n                  propertyValue += `${name}(${val}${unitType})`; // e.g rotate(100deg)\n              }\n\n              this.el.style[propertyName] = propertyValue;\n          },\n\n          'rgba': function(task, key, newArr) {\n              var text = 'rgba(';\n\n              for (var i = 0; i \u003c newArr.length - 1; i++) {\n                  text += (newArr[i]).toFixed() + ', ';\n              }\n              text += newArr[newArr.length - 1].toFixed(2) + ')';\n\n              this.el.style[task.newProps[key].realPropertyName] = text;\n          },\n\n          'default': function(task, key, newValue) {\n              this.el.style[task.newProps[key].realPropertyName] = `${newValue}${task.newProps[key].end.unitType}`;\n          }\n      };\n\n      return function(task, key, newValue) {\n          var styleLogic = task.newProps[key].styleLogic;\n\n          t[styleLogic].call(this, task, key, newValue);\n      };\n  })();\n  ```\n\n------\n\n至此，通用js动画库的两大难点基本得到解决，虽说是针对transform和color的处理方法，但在编码过程中，如何运用设计模式优化代码结构可能花费了更多的时间。"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"29"},"buildId":"xVFKlOnB1qu1k0-FevYPk","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>