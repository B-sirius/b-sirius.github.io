{"pageProps":{"id":"163","title":"R项目小结","date":"2023-01-09","mdText":"\n最近结束的一个项目有很多值得学习的地方，挑一些不敏感的在此记录。其中的每一点其实都有深入挖掘的空间，日后想必会再次遇到。\n\n---\n\n目录：\n\n- [文档设计](#文档设计)\n  - [系统设计文档](#系统设计文档)\n  - [组件文档](#组件文档)\n  - [开发者FAQ](#开发者faq)\n  - [开发者验证指南](#开发者验证指南)\n- [AWS服务](#aws服务)\n  - [ECS](#ecs)\n  - [EKS](#eks)\n  - [ECR](#ecr)\n  - [ELB](#elb)\n  - [AWS lambda](#aws-lambda)\n- [环境变量](#环境变量)\n  - [环境变量 in Next.js](#环境变量-in-nextjs)\n  - [本地环境变量](#本地环境变量)\n  - [环境变量 in Jest](#环境变量-in-jest)\n  - [在jest的setup文件中设置环境变量](#在jest的setup文件中设置环境变量)\n  - [在测试用例文件中设置环境变量](#在测试用例文件中设置环境变量)\n- [其他](#其他)\n  - [本地一切安好，线上发布缺少依赖，可能是？](#本地一切安好线上发布缺少依赖可能是)\n  - [如何更新包/组件/服务](#如何更新包组件服务)\n  - [JWT](#jwt)\n  - [Yarn2](#yarn2)\n  - [线上监控服务异常排查](#线上监控服务异常排查)\n\n## 文档设计\n\n有哪些文档可以整理归总？有的文档适合单独总结，有的适合放在Readme中，但总之，以下是一些可以考虑的点。\n\n### 系统设计文档\n\n这里的设计指的是系统的架构，尤其要关注**系统之间是如何连接的**。\n\n而以下内容不应该被包含在其中：\n\n- 服务的具体细节。\n- 组件的设计模式。\n\n### 组件文档\n\n整理所有的组件/服务，可以有以下关注点：\n\n- 介绍\n- 服务类型（比如SSR /Static）\n- 路由前缀\n- 生产环境域名\n- 预发环境域名\n- 测试环境域名（规则）\n- 仓库地址\n- 流水线地址\n- 发布分支\n- 涉及技术栈\n\n### 开发者FAQ\n\n目的是收集开发者关心的常见问题，比如项目如何本地启动，必要权限如何申请等。\n\n### 开发者验证指南\n\n目的是保证开发者提交的组件可以在生产环境中运行，而不是完全依赖QA。常见的手段有测试用例，code review等，且很可能与CI/CD流程有关。个人觉得开发者很容易对一些小改动有迷之自信，结果却提交无法在测试环境运行的代码甚至搞崩线上。该步骤非常重要又容易被忽视。\n\n## AWS服务\n\naws服务太常见了，稍微记录一下我本次接触的，不至于一些名词都没有概念。\n\n### ECS\n\nECS is Amazon Elastic **Container Service**.\n\n- Container Orchestration Service (容器编排工具）\n- Manages the whole container lifecycle.\n  - start\n  - re-schedule\n  - load balance\n- ECS Cluster（ECS集群）是Control Plane，管理所有运行着容器的虚拟机器。\n\n![How does ECS work](https://s2.loli.net/2023/01/09/u8ytTRfvmx7gk4n.jpg)\n\n- 而这些虚拟机是什么？是EC2 Instance，你还是需要管理这些Instance的，比如在增加container的时候，需要确保Instance的资源足够。\n- 但如果我们想在AWS上hosting infrastructure。可以用AWS Fargate。那就不需要手动管理Instance，他会根据你想要运行的container来自动分配资源。节省呀！\n\n### EKS\n\nEKS is Elastic **Kubernetes** Service.\n\nKubernetes 是ECS的竞品，非常Popular，所以EKS就是为了在AWS使用Kubernetes推出的。\n\nEKS的工作方式和ECS差不多。\n\n### ECR\n\nECR is Elastic **Container Registry**, a private docker registry.\n\n![whole story, Jenkins involved here!](https://s2.loli.net/2023/01/09/Lw6m7geKZ9A4YSW.png)\n\n### ELB\n\nELB is Elastic load balancing service.\n\n![负载均衡服务](https://s2.loli.net/2023/01/09/EaFjZvJ731LDGRA.png)\n\n使用这样一个 load balancer有很多好处\n\n- 将流量分配给了很多下级实例\n- 只暴露出一个入口（DNS）\n- 无缝处理下级应用的failures\n- 对实例进行健康检查\n- 提供https\n- 强制使用cookies，所以用户可以访问到同一个instance\n- …\n\n### AWS lambda\n\n这是一个Serverless服务，基本上可以理解为它提供了根据事件自动触发Function的能力。\n\n其中事件可以指的是S3的内容变化，API的请求，或其他各种各样的AWS服务事件。\n\n这里涉及到一个概念，Serverless，值得说一说。\n\n我个人的理解是这样的：\n\n首先Serverless并不是说没有Server，而是Server对用户不可见，which means：\n\n- 不需要手动管理server。\n- 会根据使用自动扩容。\n- 只有当被使用的时候，才会产生费用（而不是为Server本身付费）。\n\n![](https://s2.loli.net/2023/01/09/B2oTW3lrEuznZGK.png)\n\n## 环境变量\n\n### 环境变量 in Next.js\n\nBefore `const HOST_NAME = 'www.sample.com'`.\n\nAfter `const HOST_NAME = 'process.env.NEXT_PUBLIC_HOST_NAME'`.\n\n这里涉及到Next.js的一个特性：[expose env vars to the browser](https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser)。\n\n- During the **build stage**, next.js will find these env vars start with **NEXT_PUBLIC_** and replace them with literal.\n- build stage很关键，在CI/CD流程中，可能有build、release等多个环节，在哪里传入环境变量很关键。\n\n**Trick: 如果在一些情形下，我们需要把用于node端的环境变量暴露给浏览器，可以怎么做？**\n\n- Read these env vars inside `getServerSideProps` and return them as props. [More to read about it](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props#when-does-getserversideprops-run).\n\n```javascript\n  export const getServerSideProps = () => {\n    // we can read server side env vars here.\n    return {\n      serverConstants: {\n        TEST_HOST_NAME: process.env.TEST_HOST_NAME\n      }\n    }\n  }\n  \n  // client side.\n  export const Page = (props) => {\n    const { serverConstants } = props;\n    return (\n      <p>TEST_HOST_NAME: {serverConstants.TEST_HOST_NAME}</p>\n    )\n  }\n  ```\n\n\n### 本地环境变量\n\n关于在本地开发中使用环境变量，next.js 已经有了很好的支持，查看 [这里](https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables)。\n\n在实际场景下，可以创建一个.env.local.examlpe文件。\n\n开发者可以拷贝该文件并将其作为自己的.env.local文件。\n\n**.env.local 不应该被提交到repo中！**\n\n### 环境变量 in Jest\n\n方法是有很多的，按需采用，这里记录两种。\n\n### 在jest的setup文件中设置环境变量\n\n[文档在此](https://jestjs.io/docs/configuration#setupfilesafterenv-array)。简单来说，在这里设置的环境变量会作用于每个测试用例文件。\n\n适合用于设置默认环境变量，但无法满足需要测试不同的环境变量的场景。\n\n### 在测试用例文件中设置环境变量\n\n当然我们可以在测试用例文件中设置环境变量。\n\n只是要记住，在每个测试用例前，一定要使用 [**restModules**](https://jestjs.io/docs/jest-object#jestresetmodules) ，且**动态引入**涉及环境变量的模块。\n\n```javascript\ndescribe('environmental variables', () => {\n  const OLD_ENV = process.env;\n\n  beforeEach(() => {\n    jest.resetModules() // Most important - it clears the cache\n    process.env = { ...OLD_ENV }; // Make a copy\n  });\n\n  afterAll(() => {\n    process.env = OLD_ENV; // Restore old environment\n  });\n\n  test('will receive process.env variables', () => {\n    // Set the variables\n    process.env.NODE_ENV = 'dev';\n    process.env.PROXY_PREFIX = '/new-prefix/';\n    process.env.API_URL = 'https://new-api.com/';\n    process.env.APP_PORT = '7080';\n    process.env.USE_PROXY = 'false';\n\n    const testedModule = require('../../config/env').default // dynamic import\n\n    // ... actual testing\n  });\n});\n```\n\n## 其他\n\n### 本地一切安好，线上发布缺少依赖，可能是？\n\n规则：如果`NODE_ENV`被设置成`production`，yarn不会安装`devDependencies`中的依赖，具体可看[这里](https://classic.yarnpkg.com/en/docs/cli/install#toc-yarn-install-production-true-false)。\n\n所以这种cmd是合理的：`yarn install && yarn test && NODE_ENV=production yarn export`。\n\n相对的，如果`NODE_ENV`被设置的太早，很可能会导致`yarn test`缺少依赖。\n\n### 如何更新包/组件/服务\n\n除了更新逻辑，一般还有哪些步骤？\n\n1. 更新测试用例，保证本地测试用例通过。\n2. 本地成功运行服务。\n3. 开一个draft PR.\n   1. 将其部署到测试环境。\n   2. 在测试环境成功运行。\n4. 更新版本。（视具体情形）\n5. 找人review。\n6. 有了approvals，可以merge。\n7. 其余的就是QA、部署流程等。\n\n### JWT\n\nJWT（JSON web token）是一种常见的在客户端与服务端间传递信息的方式。\n\n1. 除非知道签名，用户是无法伪造数据的。\n2. 而header和payload本身是并没有被加密的。\n\n所以在实际应用场景中，任何人都可以查看请求的数据，但不知道签名的普通用户没办法自己构造、篡改请求。\n\n[进一步了解JWT](https://en.wikipedia.org/wiki/JSON_Web_Token)。\n\n### Yarn2\n\nYarn2 = **yarn berry**（更加准确）。和 yarn 1.x 比起来算是大改。\n\n如果使用PnP特性，yarn会生成`.pnp.cjs`以代替`node_modules`。\n\n`.pnp.cjs`只是一些maps，包括如何在文件系统中找到packages。\n\n而packages本身，是被zipped压缩过的，所以文件的数量远远少于`node_modules`。\n\n尽管package被压缩过，我们仍然可以借助`fs`的能力读取文件。\n\n**更多yarn2，欢迎阅读：**\n\n- [JavaScript package managers compared: npm, Yarn, or pnpm?](https://blog.logrocket.com/javascript-package-managers-compared/)\n- [Plug'n'Play](https://www.yarnpkg.cn/features/pnp)\n\n### 线上监控服务异常排查\n\n如果怀疑有异常的线上流量，如何排查：\n\n1. 调整时间区间，来观察流量是否是一瞬间涌入的。\n2. 比较服务端和客户端的流量，观察流量是否是直接打到服务端的。\n3. 比较流量峰值日志是否有共同点：Client IP, Country, Region, City…"},"__N_SSG":true}