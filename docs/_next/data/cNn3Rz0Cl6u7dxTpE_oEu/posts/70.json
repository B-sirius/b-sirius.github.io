{"pageProps":{"id":"70","title":"循环，还有这种操作！？","date":"2017-08-15","mdText":"\n虽说已经看了n遍相关博文，但在实际操作中各种循环的操作实在是令人摸不着头脑，系统整理一回【拍桌】\n\n## 简单 for 循环\n\n简单 for 循环一般只适用于数组，最为常见的一种写法：\n\n```javascript\nvar arr = [1, 2, 3];\nfor (var i = 0, len = arr.length; i < len; i++) {...}\n```\n\n在数组长度不变时，用`len`保存数组长度进行循环效率更佳。\n\n另外，如需在遍历中进行改变长度的删除操作，一般采用倒序遍历：\n\n```javascript\nvar arr = [1, 2, 3];\nfor (var i = arr.length - 1; i >= 0; i--) {\n  if (arr[i] === 1)\n    arr.splice(i, 1);\n}\nconsole.log(arr); // [2, 3]\n```\n\n## for-in 循环\n\n### 语法\n\n```javascript\nfor (key in object) {...}\n```\n\n### 参数\n\n`key`：每次迭代时，将不同的属性名分配给变量\n\n`object`：被迭代枚举其属性的对象\n\n### 适用情况\n\n首先咱的确可以用 for-in 来遍历数组\n\n```javascript\nvar arr = [1, 2, 3];\nfor (index in arr) {\n  console.log(`arr[${index}]: ${arr[index]}`);\n} \n// chrome中的输出结果\n// arr[0]: 1\n// arr[1]: 2\n// arr[2]: 3\n```\n\n但是注意，**for-in** 遍历的是 **对象以及其原型链上可枚举属性(`String`)，而不是数组的索引(`Number`)，且迭代顺序依赖于执行环境，并不一定按某种顺序访问元素**，数组在js中也是一个对象，属性**并非是`Number`类型而是`String`类型**。`length`属性值未被遍历也只是因为它不是可枚举属性。\n\n因此我们做出一点魔改：\n\n```javascript\nvar arr = [1, 2, 3];\narr.arrFeeling = 'fucked up';\nArray.prototype.arrayFeeling = 'thats good';\nObject.prototype.objFeeling = 'emmmmm';\nfor (key in arr) {\n  console.log(`${key + 1}: ${arr[key]}`);\n} \n// chrome中的输出结果\n// 01: 1\n// 11: 2\n// 21: 3\n// arrFeeling1: fucked up\n// arrayFeeling1: thats good\n// objFeeling1: emmmmm\n```\n\n可以看出，这里的结果已经他喵的和我们预想的数组遍历差了很多很多【震惊】，因此从某种意义上讲， for-in 遍历的初衷是遍历对象中的属性，传统的数组遍历并不适合用for-in。\n\n但是也正得益于这个特性，for-in遍历可用于遍历**稀疏数组**：\n\n```javascript\nvar arr = [];\narr[999] = 1;\nfor (key in arr) {\n  console.log(`${key}: ${arr[key]}`);\n} \n// chrome中的输出\n// 999: 1\n```\n\n此处的 `arr.length` 为1000，如果用简单for循环来输出，会遍历1000次（输出999个`undefined`），而使用for-in只会遍历一次。如果担心输出原型链上的属性，可以利用`hasOwnProperty`方法。\n\n## forEach\n\n简单的例子：\n\n```javascript\nvar arr = [null, 2, 3];\narr[5] = 5;\narr['die'] = 'die!' // 不会被遍历到\narr.forEach(function(data) {\n    console.log(data);\n});\n// null\n// 2\n// 3\n// 5\n```\n\nforEach 是Array的方法，会为数组中含**有效值（也就是说，会跳过数组空位)**(**包括值为null**)的每一**索引项**执行一次传入的回调函数。回调函数会被依次传入三个参数：\n\n- 数组当前项的值\n- 数组当前项的索引（**Number类型！**）\n- 数组对象本身\n\n需要注意的是，forEach 不会在迭代前创建数组的副本，因此**可以改变原数组**，若迭代时数组长度改变：\n\n```javascript\nvar words = [\"one\", \"two\", \"three\", \"four\"];\nwords.forEach(function(word) {\n  console.log(word);\n  if (word === \"two\") {\n    words.shift();\n  }\n});\n// one\n// two\n// four\n```\n\nforEach 的一大缺点：**一旦开始就无法跳出**，因此ES5中提供了一些其他类似的方法：\n\n- every:测试数组的所有元素是否都通过了指定函数的测试， 循环在第一次 return false 后返回，**不会改变原数组**\n- some: 测试数组中的某些元素是否通过由提供的函数实现的测试，循环在第一次 return true 后返回，**不会改变原数组**\n- filter: 返回一个新的数组，其包含通过所提供函数实现的测试的所有元素，**不会改变原数组**\n- map: 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，**不会改变原数组**\n- reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果，**啊——不会改变原数组**\n\n## for-of\n\n简单的例子：\n\n```javascript\nvar arr = [1, 2, 3];\nfor (let val of arr) {\n\tconsole.log(val);\n}\n// 1\n// 2\n// 3\n```\n\nfor-of 乍看之下和forEach的功能好像重叠了，但是作为ES6新支持的语法，自然有一些优点：\n\n- 作为正经的 for 循环语法，可以正常的 break，continue，return\n- for-of 循环并非数组专用，它支持**可迭代对象**，包括 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array), [`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Map), [`Set`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set), [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String), [`TypedArray`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)，[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments) 对象等等，注意不包括**Object**对象，如果你想迭代Object对象，for-in循环更加适合\n- 搭配ES6新增的用户自定义迭代器（说的那么模糊，因为我还不是很懂）\n\n此外，for-of与上面一大串forEach, map等有一个很大的区别：**不会跳过数组空位**:\n\n```javascript\nlet arr = ['holy', 'shit'];\narr.forEach(x => console.log(x));\n// holy\n// shit\nfor (let x of arr) {\n\tconsole.log(x);\n}\n// holy\n// undefined\n// shit\n```\n\n\n\n------\n\n最后回头看一下，循环遍历这个操作其实需要考虑很多：\n\n- 遍历方法所适用的对象\n- 是否会创建原对象副本（改变原对象）\n- 遍历时会传入的参数（`undefined`，原型链）以及参数类型（`Number`, `String`）\n- 如何处理空值\n- ...\n\n因此弄清楚他们之间的分别还是有必要的吧科科。ES6还添加了个叫**iterable**的玩意儿，也与迭代密切相关，不是很懂先坑了【逃】","description":"虽说已经看了n遍相关博文，但在实际操作中各种循环的操作实在是令人摸不着头脑，系统整理一回【拍桌】......"},"__N_SSG":true}