{"pageProps":{"id":"Evan-You-talks-about-front-end-framework","title":"聊聊前端框架——尤雨溪","date":"2018-01-29","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    p: \"p\",\n    h3: \"h3\",\n    code: \"code\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"框架选择\",\n      children: \"框架选择\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"结合场景需求\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"与开发者个人背景有关\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"不如让不同场景，不同开发者都变得更有效，因此多种方案并存是有益的\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"组件\",\n      children: \"组件\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"早期开发是以页面为单位，而现在更趋向于应用，应用则意味着组件化；而React揭示了一个事实，组件树是一个函数\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"分类\",\n      children: \"分类\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"接入型 container\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"展示型\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"交互型 比如各类加强版的表单组件，通常强调复用\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"功能型 比如 \", _jsx(_components.code, {\n          children: \"<router-view>\"\n        }), \"，\", _jsx(_components.code, {\n          children: \"<transition>\"\n        }), \"，作为一种扩展、抽象机制存在。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"模版与jsx的对比\",\n      children: \"模版与jsx的对比\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"jsx：拥有js完全的灵活度，对于功能性组件的书写远超模版\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"模版：强制性的要求在减少视图中的逻辑，以更加视图化的方式思考\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"collocation\",\n      children: \"collocation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"相关的资源（js,css之类）以组件作切分，管理；而传统的做法是按文件类型维护\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"变化侦测\",\n      children: \"变化侦测\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"pull（粗粒度）\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"react与angular，需要手动告知有变化发生，之后它们会进行“暴力的”比对（react的diff，angular的脏检查），来找到哪里有变化；因此react中有\", _jsx(_components.code, {\n            children: \"pure component\"\n          }), \"一类的东西来由用户帮助系统跳过一些比对\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"push（细粒度）\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"由'watcher'主动告知哪里发生变动，相应的会带来额外的内存开销。因此vue2.0采用组件push，内部pull（virtual dom比对）的策略\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"侦测成本与自动优化的平衡取舍\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"状态管理\",\n      children: \"状态管理\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从源事件——>状态的迁移——>状态的改变——>ui的更新\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"e.g. 鼠标点击——>应用状态改变——>ui改变\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"redux与mobx与vue？\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"问题\",\n      children: \"问题\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"异步的管理\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"局部状态与全局状态的管理\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"路由\",\n      children: \"路由\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以组件作为路由映射的基本元素\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"url可理解为序列化的状态\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React-router4将路由去中心化，用组件本身作为路由，而非是以往的集中式管理。但这对于理解路由的结构；管理路由跳转有一些问题\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"web路由与应用路由区别\",\n      children: \"web路由与应用路由区别\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"web路由方案，相对于应用路由，在跳转中状态被丢弃，而非是一层层的叠加状态\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"css方案\",\n      children: \"css方案\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"主流的-css-方案\",\n      children: \"主流的 CSS 方案\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"跟 JS 完全解耦，靠预处理器和比如 BEM 这样的规范来保持可维护性，偏传统\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"CSS Modules，依然是 CSS，但是通过编译来避免 CSS 类名的全局冲突\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"各类 CSS-in-JS 方案，React 社区为代表，比较激进\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面），一种比较折中的方案\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"传统-css-的一些问题\",\n      children: \"传统 css 的一些问题\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"作用域 —— 几种解决方案已经基本ok\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Critical CSS —— 对于服务端渲染尤为重要，因此需要在服务端侦测到页面用到了哪些css，vue可以在编译时将css插入与组件的生命周期挂钩，而css in js\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Atomic CSS（原子类）—— 优点，css体积小，不过由静态编译去进行这种处理也完全可行\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"分发复用\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"跨平台复用\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"description":"- 结合场景需求......","usedCustomComponentNames":[]},"__N_SSG":true}