{"pageProps":{"id":"impact-checking-between-square-and-circle","title":"弹一弹#2 方块与圆の碰撞物语","date":"2018-05-03","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    hr: \"hr\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    a: \"a\",\n    img: \"img\",\n    ul: \"ul\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"编译原理好鸡儿难，课设真尼玛烦，俺现在只想摸鱼 _(┐「ε:)_\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"前言\",\n      children: \"前言\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于两个物体之间的碰撞检测，依据两个物体本身属性的不同，所采取的策略也不尽相同。简单的来说可以分为3大类：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"依据每一帧中，几何图形的重合来检测\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"基于像素、地图格子来检测\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"基于速度矢量与相应判别条件来检测\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在弹一弹的例子中，第一种应该是首要的检测方式，后面两种如果俺开心再写吧【滑稽】\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而在第一种中，又有几种不同的情形需要采取不同策略对待：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"圆-圆\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"无旋转矩形-无旋转矩形\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"圆-矩形（可有旋转）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"任意多边形\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其中1和2都太过耿直，在此不做说明。本水文着重讨论第3种情形，第4种会更的嗯，俺有骗过你么 （’へ’）\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"圆--无旋转方块儿\",\n      children: \"圆 & 无旋转方块儿\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我们要解决的问题，本质上就是要知道圆与矩形有无“接触”——而有了圆-圆检测的经验后，不难想到，我们要做的就是找到\", _jsx(_components.strong, {\n        children: \"矩形上离圆最近的点\"\n      }), \"，通过这一点到圆心的距离与圆的半径之间的比较，就能确定圆与矩形是否接触：\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"图片来源：\", _jsx(_components.a, {\n        href: \"https://aotu.io/notes/2017/02/16/2d-collision-detection/\",\n        children: \"凹凸实验室\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-1.png\",\n        alt: \"情形2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-2.png\",\n        alt: \"情形1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-3.png\",\n        alt: \"情形1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不难看出这个最近点在x轴、y轴与圆心之间的关系，可以参考下面这个demo：\"\n    }), \"\\n\", _jsxs(\"p\", {\n      \"data-height\": \"265\",\n      \"data-theme-id\": \"0\",\n      \"data-slug-hash\": \"YLpBZM\",\n      \"data-default-tab\": \"js,result\",\n      \"data-user\": \"padfoot_07\",\n      \"data-embed-version\": \"2\",\n      \"data-pen-title\": \"rect&ball\",\n      class: \"codepen\",\n      children: [\"See the Pen \", _jsx(\"a\", {\n        href: \"https://codepen.io/padfoot_07/pen/YLpBZM/\",\n        children: \"rect&ball\"\n      }), \" by Zhouyi (\", _jsx(\"a\", {\n        href: \"https://codepen.io/padfoot_07\",\n        children: \"@padfoot_07\"\n      }), \") on \", _jsx(\"a\", {\n        href: \"https://codepen.io\",\n        children: \"CodePen\"\n      }), \".\"]\n    }), \"\\n\", _jsx(\"script\", {\n      async: true,\n      src: \"https://static.codepen.io/assets/embed/ei.js\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"圆--旋转方块儿\",\n      children: \"圆 & 旋转方块儿\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果矩形旋转了a度，只需要\", _jsx(_components.strong, {\n        children: \"以矩形中心为旋转中心，旋转画布-a度\"\n      }), \"，我们就又回到了上面一种无旋转情形！\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"换而言之，我们需要额外做的，就是计算\", _jsx(_components.strong, {\n        children: \"旋转后的圆心\"\n      }), \"。那么首先推导一下某个点绕原点旋转一定角度后的坐标：\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"证明来源：\", _jsx(_components.a, {\n        href: \"https://aotu.io/notes/2017/02/16/2d-collision-detection/\",\n        children: \"凹凸实验室\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-4.png\",\n        alt: \"原点旋转\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A为旋转前，B为原点，C为旋转后，r为半径，则\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"由于 |AB| 与 |CB| 相等（即长度），且\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"|AB| = y/sin(δ) = x / cos(δ)\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"|CB| = d/sin(δ + β) = c / cos(δ + β)\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"三角函数两角和差公式：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"得出旋转后的坐标\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那么对于旋转中心 (centerX, centerY) ，其实只要做一个坐标轴平移的工作：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-5.png\",\n        alt: \"绕某点旋转\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-javascript\",\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [\"x’ \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"cos\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"β\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"cx – centerX\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" – \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"sin\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"β\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"cy – centerY\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"+\"\n        }), \" centerX\\ny’ \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"sin\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"β\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"cx – centerX\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"+\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"cos\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"β\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"*\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"cy – centerY\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"+\"\n        }), \" centerY\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以上就是我们需要的旋转公式。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下面这个demo中应用了上述理论，透明度较低的是旋转后的图形：\"\n    }), \"\\n\", _jsxs(\"p\", {\n      \"data-height\": \"265\",\n      \"data-theme-id\": \"0\",\n      \"data-slug-hash\": \"rvmKKj\",\n      \"data-default-tab\": \"js,result\",\n      \"data-user\": \"padfoot_07\",\n      \"data-embed-version\": \"2\",\n      \"data-pen-title\": \"rotatedRect&ball\",\n      class: \"codepen\",\n      children: [\"See the Pen \", _jsx(\"a\", {\n        href: \"https://codepen.io/padfoot_07/pen/rvmKKj/\",\n        children: \"rotatedRect&ball\"\n      }), \" by Zhouyi (\", _jsx(\"a\", {\n        href: \"https://codepen.io/padfoot_07\",\n        children: \"@padfoot_07\"\n      }), \") on \", _jsx(\"a\", {\n        href: \"https://codepen.io\",\n        children: \"CodePen\"\n      }), \".\"]\n    }), \"\\n\", _jsx(\"script\", {\n      async: true,\n      src: \"https://static.codepen.io/assets/embed/ei.js\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"好了不多说了，我只想看下一集小英雄，再见了您！\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"description":"编译原理好鸡儿难，课设真尼玛烦，俺现在只想摸鱼 \\_(┐「ε:)\\_......","usedCustomComponentNames":[]},"__N_SSG":true}