{"pageProps":{"id":"use-github-actions-and-cloudflare-pages-improve-blog-online-process","title":"使用Github Actions与CloudFlare Pages优化博客上线流程","date":"2023-02-14","htmlText":"<html><head></head><body><p>在之前的文章<a href=\"https://b-sirius.github.io/posts/use-nextjs-create-SSG-blog\" target=\"_blank\" rel=\"nofollow\">你的静态博客，何必是hexo</a>中，我大概介绍了如何搭建一个个人静态博客，但并没有涉及要如何将其上线。</p>\n<p>我个人的首选方案是Github Pages，因为它免费，且域名直观。</p>\n<p>在最初的时候，要发布一篇新的博客（或者做一些功能更新），我要手动做以下几步工作：</p>\n<ol>\n<li>在博客仓库（<code>&#x3C;username>.github.io</code>）切出一个本地新分支；</li>\n<li>在分支上完成博客内容的编写；</li>\n<li>本地运行<code>yarn export</code>构建，生成<code>/docs</code>目录（github pages只允许指定目录为根目录或docs目录）；</li>\n<li>将更新过的代码推上远端分支；</li>\n<li>发起PR；</li>\n<li>合并PR；</li>\n<li>等待Github Pages重新部署，去线上验证博客是否更新成功；</li>\n</ol>\n<p>在多次不断的重复以上操作后，我意识到了几个问题：</p>\n<ol>\n<li>我经常忘记本地export构建，因为启动dev环境是不需要这一步的；</li>\n<li>博客仓库同时包含了源代码与构建产物代码，如果fork&#x26;clone的话，构建产物代码其实是完全没有用的；</li>\n<li>我只有在合并了main分支后才能验证线上博客是否更新成功。如果发生了本地环境没有出现的问题，那就意味着我的线上生产环境崩掉了；</li>\n</ol>\n<p>这种情形下，引入一些CI/CD工具实现<strong>自动触发</strong>的<strong>线上构建部署</strong>是常见的解决方案。我将会介绍<strong>Github Actions</strong>以及<strong>CloudFlare Pages</strong>，看看这两个免费服务可以帮我们实现怎样的自动化。</p>\n<p>【剧透】最终实现如下：</p>\n<p><img src=\"https://s2.loli.net/2023/02/14/iljSW7nucVfgAF1.png\" alt=\"优化博客部署.png\"></p>\n<p>目录：</p>\n<ul>\n<li><a href=\"#github-actions\">Github Actions</a></li>\n<li><a href=\"#cloudflare-pages\">CloudFlare Pages</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n<h2 id=\"github-actions\">Github Actions</h2>\n<p>介绍它的文章很多，因此我不打算展开。直接说它的特点：</p>\n<ol>\n<li>它可以被各种各样的Github操作自动触发——比如新建分支、open PR、push到某个分支，也支持通过Github API手动触发（<code>workflow_dispatch</code>）</li>\n<li>Github维护了一个Action市场，开发者可以使用社区贡献的Action而无需自己重新手写各种常用功能。比如获取当前的分支、指定node版本、将指定目录推送到Amazon S3。</li>\n</ol>\n<p>以我将博客推送到Github Pages的workflow为例：</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># .github/workflows/production.yml</span>\n<span class=\"token comment\"># 所有的workflow必须放在.github/workflows目录下才能被识别，文件名会作为该workflow的名称</span>\n\n<span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy for production\n\n<span class=\"token comment\"># on指定了该workflow的触发时机</span>\n<span class=\"token comment\"># 这里是指定在main分支有更新时触发（直接push或者merge进main分支都会触发该时间）</span>\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> main\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># job id</span>\n  <span class=\"token key atrule\">production</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># runs-on指定了运行任务的机器类型，值得一提的是，我们可以使用自己的机器（比如需要支持内网环境），更多可以去了解“self-hosted runner”</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token comment\"># environment指的就是仓库设置中 Actions secrets and variables 对应的environment，用于区分变量环境</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span> production\n\n    <span class=\"token comment\"># steps就是每个job具体的步骤</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token comment\"># uses代表了这里使用了一个社区贡献的action</span>\n      <span class=\"token comment\"># checkout到指定分支</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v3\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">ref</span><span class=\"token punctuation\">:</span> main\n\n      <span class=\"token comment\"># 指定node版本</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v3\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token number\">16</span>\n\n      <span class=\"token comment\"># yarn install</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> borales/actions<span class=\"token punctuation\">-</span>yarn@v4\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> yarn install\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">cmd</span><span class=\"token punctuation\">:</span> install\n\n      <span class=\"token comment\"># yarn export</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> borales/actions<span class=\"token punctuation\">-</span>yarn@v4\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> yarn export\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">cmd</span><span class=\"token punctuation\">:</span> export\n\n      <span class=\"token comment\"># 将上一步的构建目录推动到指定仓库的指定分支</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Pushes to the blog github pages\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> cpina/github<span class=\"token punctuation\">-</span>action<span class=\"token punctuation\">-</span>push<span class=\"token punctuation\">-</span>to<span class=\"token punctuation\">-</span>another<span class=\"token punctuation\">-</span>repository@main\n        <span class=\"token key atrule\">env</span><span class=\"token punctuation\">:</span>\n          <span class=\"token comment\"># secrets在仓库settings中进行设置好，在对应的环境便可读取</span>\n          <span class=\"token key atrule\">API_TOKEN_GITHUB</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.API_TOKEN_GITHUB <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">source-directory</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'docs'</span>\n          <span class=\"token key atrule\">destination-github-username</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'B-sirius'</span>\n          <span class=\"token key atrule\">destination-repository-name</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'b-sirius.github.io'</span>\n          <span class=\"token key atrule\">target-branch</span><span class=\"token punctuation\">:</span> main\n</code></pre>\n<p>有了这样一个自动触发的工作流后，我便拆分出了博客源代码仓库。每次源代码仓库的main分支更新时，Github Actions会自动去进行构建，并将构建结果push到Github Pages使用的仓库<a href=\"https://github.com/B-sirius/b-sirius.github.io\" target=\"_blank\" rel=\"nofollow\">b-sirius.github.io</a>的main分支。而Github Pages也会在main更新时，自动触发部署，更新线上页面。于是我之前提到的痛点的前两个，就都解决了。</p>\n<h2 id=\"cloudflare-pages\">CloudFlare Pages</h2>\n<p>于是我还剩下一个问题：如何支持测试（preview）环境？对于任何应用来说，在本地验证与生产环境发布之间，至少还需要在测试环境验证一次。Github Pages目前还没有对preview环境的官方支持（尽管应该是在<a href=\"https://github.com/community/community/discussions/7730\" target=\"_blank\" rel=\"nofollow\">进展之中</a>），所以我个人选择了一个简单的方案：再使用一家pages服务，如CloudFlare Pages、Vercel。他们二者都与Git有很好的集成，以下将以CloudFlare Pages为例。</p>\n<p>注册登录关联git仓库这些都没什么好说的，都是固定流程，在这些绑定完成后，我们就需要去做一些具体的设置了。</p>\n<p>默认情况下，CloudFlare Pages会为main分支自动部署production环境，对所有其余分支自动部署preview环境，后者正好就满足了我们的需要，而前者我不需要，于是将其设置将其关闭。</p>\n<p><img src=\"https://s2.loli.net/2023/02/14/HVPWFqh7Gwstz1J.png\" alt=\"分支部署\"></p>\n<p>在构建设置中，其实只要指定构建命令与用于上传的构建目录，这部分的配置自然上面的github workflow其实是一模一样的。</p>\n<p><img src=\"https://s2.loli.net/2023/02/14/ZantFJBoziTp5XS.png\" alt=\"构建设置\"></p>\n<p>有一个小细节是，在github workflow中我们指定了node版本，CloudFlare Pages也支持这一点，通过环境变量的方式，你可以在这里看到更多支持的<a href=\"https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables\" target=\"_blank\" rel=\"nofollow\">环境变量</a>。</p>\n<p><img src=\"https://s2.loli.net/2023/02/14/oxYwl26eGp8daWS.png\" alt=\"指定node版本\"></p>\n<h2 id=\"总结\">总结</h2>\n<p>于是，我们就实现了这样一个简单却实用的CI/CD流水线。可以看出：</p>\n<ol>\n<li>Github Actions其实是一个非常灵活的hook工具，可以去自定义触发各种各样有趣的任务（类似的服务还有Amazon Lambda）；</li>\n<li>Github Pages是一个纯粹的静态站点托管服务，上传静态站点，它就呈现；</li>\n<li>CloudFlare Pages和Vercel也是静态站点托管服务，但是它们更加注重与其他平台的集成，并通过低码的方式去完成简单的构建部署以及呈现；</li>\n</ol>\n<p>最终，整个博客部署的步骤如下，只有虚线的关键卡点步骤是手动操作，而其余的工作都会自动完成，很方便吧。</p>\n<p><img src=\"https://s2.loli.net/2023/02/14/iljSW7nucVfgAF1.png\" alt=\"优化博客部署.png\"></p>\n</body></html>","description":"我个人的首选方案是Github Pages，因为它免费，且域名直观。......"},"__N_SSG":true}