{"pageProps":{"id":"about-web-view","title":"WebView的世界","date":"2023-12-06","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    strong: \"strong\",\n    a: \"a\",\n    ul: \"ul\",\n    code: \"code\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"当H5遇上WebView，我们会遇到哪些常见的需求/问题？\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"颜色适应\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"APP调起\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"数据通信\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"兼容性\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"颜色适应\",\n      children: \"颜色适应\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以细分为两种情形：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"APP内的同一处页面需要支持不同颜色展示，常见于APP支持设置亮色、暗色主题\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"APP内不同处用到了同一页面，但是需要该页面可支持多种主题色。常见为通用H5在多处被复用，甚至在多APP内被复用。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"场景1\",\n      children: \"场景1：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"关键词：\", _jsx(_components.strong, {\n        children: _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\",\n          children: \"prefers-color-scheme\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通过这个媒体查询，H5可以定制一套dark样式。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但你就不得不问了，这个媒体查询什么时候生效？WebView可以控制么？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一般在默认情况下，prefers-colors-scheme会跟随系统主题生效。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那WebView能进一步控制么？毕竟很多的App是允许用户手动设置浅色/深色模式的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"答案是可以的。建议参考这两篇指南：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://developer.android.com/develop/ui/views/layout/webapps/dark-theme\",\n          children: \"Darken web content in WebView  | Android Developers\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://useyourloaf.com/blog/supporting-dark-mode-in-wkwebview/\",\n          children: \"Supporting Dark Mode In WKWebView (useyourloaf.com)\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"上述指南还包含三个进阶知识点：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"H5增加\", _jsxs(_components.strong, {\n          children: [\"meta tag \", _jsx(_components.code, {\n            children: \"<meta name=\\\"color-scheme\\\" content=\\\"dark light\\\" />\"\n          }), \" 可以更好的帮助APP使用正确的颜色配置。\"]\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"即使没有设置prefers-color-schema，WebView其实也支持通过算法为H5生成一套深色外观。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在CSS中设置\", _jsx(_components.code, {\n          children: \"color-scheme\"\n        }), \"可以帮助滚动条、Textarea元素等自带样式的控件应用正确的外观。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"e.g. hacker news自动生成的深色外观：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://s2.loli.net/2023/12/06/Dj2iHASFUugO7ml.png\",\n        alt: \"hacker news1.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://s2.loli.net/2023/12/06/ADZGqs3NMeu1wdn.png\",\n        alt: \"hacker news2.png\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"场景2\",\n      children: \"场景2：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"场景2需要为页面做动态样式渲染，也就是说WebView需要给H5传样式参数，来得到不同的样式。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那么参数怎么传，以及H5怎么接收参数，怎么渲染呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其实WebView和H5之间通信是之后的话题，考虑到这里只需要WebView单向的往H5传参，最常见的想法就是：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"URL search parameters\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"JS bridge\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这些方案都行，但用它们做样式动态设置其实并不太好，因为一定会产生\", _jsx(_components.strong, {\n        children: \"肉眼可见的样式变化延迟\"\n      }), \"——参数的接收和生效都是在客户端进行的，JS后置，这个延迟一般能有几百毫秒。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"更好的方案？你可能已经想到了，我个人觉得动态路由+SSR非常适合这种场景。使用动态路由就可以在服务端完成参数的接收，那么返回的HTML就是参数已经生效的版本，一切都会显得非常的丝滑。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"app调起\",\n      children: \"APP调起\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"唤端：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"IOS：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"URI Scheme，不推荐，理由有\", \"\\n\", _jsxs(_components.ul, {\n              children: [\"\\n\", _jsx(_components.li, {\n                children: \"无法实际判断唤端成功与否，一般通过页面计时来猜测是否成功，体验并不好\"\n              }), \"\\n\", _jsx(_components.li, {\n                children: \"失败的时候，会提示不认得这个链接，看起来像个报错\"\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Universal link，目前官方最推荐的方法\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Android\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"URI Scheme似乎表现尚可\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"数据通信方法互相调用\",\n      children: \"数据通信，方法互相调用\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"JS bridge是比较常见的方案，JS需要将方法暴露到window上，然后flutter就可以调用该方法。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Flutter的WebView插件\", _jsx(_components.a, {\n          href: \"https://inappwebview.dev/\",\n          children: \"InAppWebview\"\n        }), \"，本身提供了handler进行数据通信\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"兼容性\",\n      children: \"兼容性\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当遇到兼容性问题的时候，首先我们关心的就是WebView内核版本。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"android\",\n      children: \"Android\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"安卓的WebView是一个独立的组件。因此当遇到兼容问题的时候，首先要查看它的版本。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一般可以在设置中打开开发者模式后，找到对应的信息：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://s2.loli.net/2023/12/06/QBEgJOPjlVDYxMT.png\",\n        alt: \"WebView version.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"顺带一提，升级系统WebView的方式：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"大陆的安卓手机系统一般是通过升级系统版本随带更新WebView版本。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"支持Google服务的安卓手机系统可通过Google Play单独升级系统WebView版本。\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"description":"可能长期更新，在做WebView时遇到的一些常见问题。","usedCustomComponentNames":[]},"__N_SSG":true}