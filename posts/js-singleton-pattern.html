<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="js设计模式——单例模式"/><meta property="og:title" content="js设计模式——单例模式"/><meta property="og:description" content="单例模式应该是我最早接触的设计模式之一，尽管如此，前两天在写IFE的任务时还是懵比了好一阵，他喵的还是总结一下比较好。......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f164db4954bac6ec.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/332-e879213584d084bf.js" defer=""></script><script src="/_next/static/chunks/740-8163689fd2f6810b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-09693cab6fb7ef9a.js" defer=""></script><script src="/_next/static/qK3XdjXrKg_JAR2H1GNBN/_buildManifest.js" defer=""></script><script src="/_next/static/qK3XdjXrKg_JAR2H1GNBN/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-b711fa3b-0 dxGMRG"><div class="sc-7fa12c98-0 iqAzDm"><div class="sc-357ac6e1-1 blSmbb"><div class="sc-357ac6e1-0 fqUBXX"><a class="sc-357ac6e1-2 gfNIvm" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-357ac6e1-2 gfNIvm" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f5ce872-0 drvesR"><h1 class="sc-f5ce872-1 jPBPjm">LWDW!</h1><p class="sc-f5ce872-2 djaGsH">Learn the work from doing the work🍺</p></div></div><div class="sc-920e94b6-0 sc-20291786-0 cMfBpD eCERES"><div><div class="sc-edf62e18-0 kyUQvd"><div class="sc-edf62e18-2 irplQW">js设计模式——单例模式</div><div class="sc-edf62e18-3 hMZjOA">Posted on <!-- -->2016-11-28</div></div></div></div><div class="sc-920e94b6-0 cMfBpD"><div><div class="sc-edf62e18-1 jVTVVD"><div class="sc-29ea8e37-0 bjoUyc"></div></div></div></div><div class="sc-bbd5e802-0 cbkQsN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"js-singleton-pattern","title":"js设计模式——单例模式","date":"2016-11-28","mdText":"\n单例模式应该是我最早接触的设计模式之一，尽管如此，前两天在写IFE的任务时还是懵比了好一阵，他喵的还是总结一下比较好。\n\n**PS:以下代码及相当一部分内容来源于 《javascript设计模式与开发实践》——曾探  ，非完全原创！**\n\n## 什么是单例模式\n\n**“保证一个类有且仅有一个实例，并提供一个访问他的全局访问点”。**\n\n## 标准的单例模式\n\n原理很简单，就是用一个变量来标志当前是否为某个类创建过对象，如果创建过，下一次获取该类的实例时，直接返回该对象：\n\n```javascript\nvar Singleton = function(name) {\n    this.name = name;\n    this.instance = null;\n};\nSingleton.prototype.getName = function() {\n    alert(this.name);\n};\nSingleton.getInstance = function(name) {\n    if (!this.instance) {\n        this.instance = new Singleton(name);\n    }\n    return this.instance;\n};\nvar a = Singleton.getInstance('sven1');\nvar b = Singleton.getInstance('sven2');\nalert(a === b);\n// true\n```\n或者：\n\n```javascript\nvar Singleton = function(name) {\n    this.name = name;\n};\nSingleton.prototype.getName = function() {\n    alert(this.name);\n};\nSingleton.getInstance = (function() {\n    var instance = null;\n    return function(name) {\n        if (!instance) {\n            instance = new Singleton(name);\n        }\n        return instance;\n    }\n})();\n```\n\n这两种方法都是通过getInstance方法来获取唯一对象，不过缺点很明显，如果这个类使用者使用new方法创建实例，还是会有新的实例产生。\n\n## JS的单例模式\n\nJS其实本身没有提供类的实现方法，当然在ES6中我们可以使用CLASS了，不过这只是语法糖而已，并非是新的继承模型，那我们其实可以搞一些JS特色的单例模式啊。\n\n### 全局变量？\n\n全局变量当然不是单例模式，但是我们其实常常这么用，比如`var a = {};`，这样创建对象自然是独一无二的，不过全局变量容易造成命名空间污染，对此我们可以使用命名空间：\n\n```javascript\nvar namespace1 = {\n    a: function() {\n        alert(1);\n    },\n    b: function() {\n        alert(2);\n    }\n};\n```\n\n或使用闭包：\n\n```javascript\nvar user = (function() {\n    var __name = 'sven',\n        __age = 29;\n    return {\n        getUserInfo: function() {\n            return __name + '-' + __age;\n        }\n    }\n})();\n```\n\n### 惰性单例\n\n惰性单例就是指在需要时才创建对象实例，上文的代码其实就是惰性单例了，但是实在是不够抽象，我们可以分离出真正interesting的部分：\n\n```javascript\nvar getSingle = function(fn) {\n    var result;\n    return function() {\n        return result || (result = fn.apply(this, arguments));\n    }\n};\n```\n\n注意是创建对象的方法被当成参数传入getSingle函数，在让getSingle返回一个新的**函数！**并且用result返回fn的计算结果，因为result在闭包中，所以不会被销毁，一个完整的例子：\n\n```javascript\nvar createLoginLayer = function() {\n    var div = document.createElement('div');\n    div.innerHTML = '我是登录浮窗';\n    div.style.display = 'none';\n    document.body.appendChild(div);\n    return div;\n};\nvar createSingleLoginLayer = getSingle(createLoginLayer);\ndocument.getElementById('loginBtn').onclick = function() {\n    var loginLayer = createSingleLoginLayer();\n    loginLayer.style.display = 'block';\n};\n```\n\n## 最疼的方法——重写构造函数\n\n这个方法是在[这篇博客](https://cnodejs.org/topic/520dc59899f5db772c01ce1f)看到的，给人一种《逃生2》的断子绝孙之感：\n\n```javascript\nfunction Person() {\n    //缓存实例 \n    var instance = this;\n    //重写构造函数 \n    Person = function() {\n            return instance;\n        }\n        //保留原型属性 \n    Person.prototype = this;\n    //实例 \n    instance = new Person();\n    //重置构造函数引用 \n    instance.constructor = Person;\n\n    //其他初始化 \n    instance.createTime = new Date();\n\n    return instance;\n}\n```\n\n简单的来说就是构造函数第一次调用时，一开始就直接改写自身的构造函数令其将来执行时直接返回实例，再有条不紊地保留**原型属性**与**构造函数引用**（否则一旦对象被创建，其原型将被改变），最后再开始构造实例的工作，实在太优雅（而且感觉很疼）了[茶]。\n\n--------------------\n\n诶～设计模式真是四国一啊ᕕ ( ᐛ ) ᕗ","description":"单例模式应该是我最早接触的设计模式之一，尽管如此，前两天在写IFE的任务时还是懵比了好一阵，他喵的还是总结一下比较好。......"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"js-singleton-pattern"},"buildId":"qK3XdjXrKg_JAR2H1GNBN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>