<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="使用Github Actions与CloudFlare Pages优化博客上线流程"/><meta property="og:title" content="使用Github Actions与CloudFlare Pages优化博客上线流程"/><meta property="og:description" content="我个人的首选方案是Github Pages，因为它免费，且域名直观。......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f164db4954bac6ec.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/332-e879213584d084bf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-1cba9b73018ff034.js" defer=""></script><script src="/_next/static/H4PWxIBNlZzCnB52z8dny/_buildManifest.js" defer=""></script><script src="/_next/static/H4PWxIBNlZzCnB52z8dny/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-590e23a2-0 iUjvom"><div class="sc-7fa12c98-0 iqAzDm"><div class="sc-357ac6e1-1 blSmbb"><div class="sc-357ac6e1-0 fqUBXX"><a class="sc-357ac6e1-2 gfNIvm" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-357ac6e1-2 gfNIvm" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f5ce872-0 drvesR"><h1 class="sc-f5ce872-1 jPBPjm">LWDW!</h1><p class="sc-f5ce872-2 djaGsH">Learn the work from doing the work🍺</p></div></div><div class="sc-920e94b6-0 sc-659069c1-0 cMfBpD jHWfVM"><div><div class="sc-32c5999b-0 iFBmZi"><div class="sc-32c5999b-2 fHkOeB">使用Github Actions与CloudFlare Pages优化博客上线流程</div><div class="sc-32c5999b-3 deKveP">Posted on <!-- -->2023-02-14</div></div></div></div><div class="sc-920e94b6-0 cMfBpD"><div><div class="sc-32c5999b-1 fNXLto"><div class="sc-a2d97488-0 dmbacr"><div><html><head></head><body><p>在之前的文章<a href="https://b-sirius.github.io/posts/use-nextjs-create-SSG-blog" target="_blank" rel="nofollow">你的静态博客，何必是hexo</a>中，我大概介绍了如何搭建一个个人静态博客，但并没有涉及要如何将其上线。</p>
<p>我个人的首选方案是Github Pages，因为它免费，且域名直观。</p>
<p>在最初的时候，要发布一篇新的博客（或者做一些功能更新），我要手动做以下几步工作：</p>
<ol>
<li>在博客仓库（<code>&#x3C;username>.github.io</code>）切出一个本地新分支；</li>
<li>在分支上完成博客内容的编写；</li>
<li>本地运行<code>yarn export</code>构建，生成<code>/docs</code>目录（github pages只允许指定目录为根目录或docs目录）；</li>
<li>将更新过的代码推上远端分支；</li>
<li>发起PR；</li>
<li>合并PR；</li>
<li>等待Github Pages重新部署，去线上验证博客是否更新成功；</li>
</ol>
<p>在多次不断的重复以上操作后，我意识到了几个问题：</p>
<ol>
<li>我经常忘记本地export构建，因为启动dev环境是不需要这一步的；</li>
<li>博客仓库同时包含了源代码与构建产物代码，如果fork&#x26;clone的话，构建产物代码其实是完全没有用的；</li>
<li>我只有在合并了main分支后才能验证线上博客是否更新成功。如果发生了本地环境没有出现的问题，那就意味着我的线上生产环境崩掉了；</li>
</ol>
<p>这种情形下，引入一些CI/CD工具实现<strong>自动触发</strong>的<strong>线上构建部署</strong>是常见的解决方案。我将会介绍<strong>Github Actions</strong>以及<strong>CloudFlare Pages</strong>，看看这两个免费服务可以帮我们实现怎样的自动化。</p>
<p>【剧透】最终实现如下：</p>
<p><img src="https://s2.loli.net/2023/02/14/iljSW7nucVfgAF1.png" alt="优化博客部署.png"></p>
<h2 id="github-actions">Github Actions</h2>
<p>介绍它的文章很多，因此我不打算展开。直接说它的特点：</p>
<ol>
<li>它可以被各种各样的Github操作自动触发——比如新建分支、open PR、push到某个分支，也支持通过Github API手动触发（<code>workflow_dispatch</code>）</li>
<li>Github维护了一个Action市场，开发者可以使用社区贡献的Action而无需自己重新手写各种常用功能。比如获取当前的分支、指定node版本、将指定目录推送到Amazon S3。</li>
</ol>
<p>以我将博客推送到Github Pages的workflow为例：</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># .github/workflows/production.yml</span>
<span class="token comment"># 所有的workflow必须放在.github/workflows目录下才能被识别，文件名会作为该workflow的名称</span>

<span class="token key atrule">name</span><span class="token punctuation">:</span> Deploy for production

<span class="token comment"># on指定了该workflow的触发时机</span>
<span class="token comment"># 这里是指定在main分支有更新时触发（直接push或者merge进main分支都会触发该时间）</span>
<span class="token key atrule">on</span><span class="token punctuation">:</span>
  <span class="token key atrule">push</span><span class="token punctuation">:</span>
    <span class="token key atrule">branches</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> main

<span class="token key atrule">jobs</span><span class="token punctuation">:</span>
  <span class="token comment"># job id</span>
  <span class="token key atrule">production</span><span class="token punctuation">:</span>
    <span class="token comment"># runs-on指定了运行任务的机器类型，值得一提的是，我们可以使用自己的机器（比如需要支持内网环境），更多可以去了解“self-hosted runner”</span>
    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest
    <span class="token comment"># environment指的就是仓库设置中 Actions secrets and variables 对应的environment，用于区分变量环境</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span> production

    <span class="token comment"># steps就是每个job具体的步骤</span>
    <span class="token key atrule">steps</span><span class="token punctuation">:</span>
      <span class="token comment"># uses代表了这里使用了一个社区贡献的action</span>
      <span class="token comment"># checkout到指定分支</span>
      <span class="token punctuation">-</span> <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">ref</span><span class="token punctuation">:</span> main

      <span class="token comment"># 指定node版本</span>
      <span class="token punctuation">-</span> <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>node@v3
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">node-version</span><span class="token punctuation">:</span> <span class="token number">16</span>

      <span class="token comment"># yarn install</span>
      <span class="token punctuation">-</span> <span class="token key atrule">uses</span><span class="token punctuation">:</span> borales/actions<span class="token punctuation">-</span>yarn@v4
        <span class="token key atrule">name</span><span class="token punctuation">:</span> yarn install
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">cmd</span><span class="token punctuation">:</span> install

      <span class="token comment"># yarn export</span>
      <span class="token punctuation">-</span> <span class="token key atrule">uses</span><span class="token punctuation">:</span> borales/actions<span class="token punctuation">-</span>yarn@v4
        <span class="token key atrule">name</span><span class="token punctuation">:</span> yarn export
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">cmd</span><span class="token punctuation">:</span> export

      <span class="token comment"># 将上一步的构建目录推动到指定仓库的指定分支</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Pushes to the blog github pages
        <span class="token key atrule">uses</span><span class="token punctuation">:</span> cpina/github<span class="token punctuation">-</span>action<span class="token punctuation">-</span>push<span class="token punctuation">-</span>to<span class="token punctuation">-</span>another<span class="token punctuation">-</span>repository@main
        <span class="token key atrule">env</span><span class="token punctuation">:</span>
          <span class="token comment"># secrets在仓库settings中进行设置好，在对应的环境便可读取</span>
          <span class="token key atrule">API_TOKEN_GITHUB</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> secrets.API_TOKEN_GITHUB <span class="token punctuation">}</span><span class="token punctuation">}</span>
        <span class="token key atrule">with</span><span class="token punctuation">:</span>
          <span class="token key atrule">source-directory</span><span class="token punctuation">:</span> <span class="token string">'docs'</span>
          <span class="token key atrule">destination-github-username</span><span class="token punctuation">:</span> <span class="token string">'B-sirius'</span>
          <span class="token key atrule">destination-repository-name</span><span class="token punctuation">:</span> <span class="token string">'b-sirius.github.io'</span>
          <span class="token key atrule">target-branch</span><span class="token punctuation">:</span> main
</code></pre>
<p>有了这样一个自动触发的工作流后，我便拆分出了博客源代码仓库。每次源代码仓库的main分支更新时，Github Actions会自动去进行构建，并将构建结果push到Github Pages使用的仓库<a href="https://github.com/B-sirius/b-sirius.github.io" target="_blank" rel="nofollow">b-sirius.github.io</a>的main分支。而Github Pages也会在main更新时，自动触发部署，更新线上页面。于是我之前提到的痛点的前两个，就都解决了。</p>
<h2 id="cloudflare-pages">CloudFlare Pages</h2>
<p>于是我还剩下一个问题：如何支持测试（preview）环境？对于任何应用来说，在本地验证与生产环境发布之间，至少还需要在测试环境验证一次。Github Pages目前还没有对preview环境的官方支持（尽管应该是在<a href="https://github.com/community/community/discussions/7730" target="_blank" rel="nofollow">进展之中</a>），所以我个人选择了一个简单的方案：再使用一家pages服务，如CloudFlare Pages、Vercel。他们二者都与Git有很好的集成，以下将以CloudFlare Pages为例。</p>
<p>注册登录关联git仓库这些都没什么好说的，都是固定流程，在这些绑定完成后，我们就需要去做一些具体的设置了。</p>
<p>默认情况下，CloudFlare Pages会为main分支自动部署production环境，对所有其余分支自动部署preview环境，后者正好就满足了我们的需要，而前者我不需要，于是将其设置将其关闭。</p>
<p><img src="https://s2.loli.net/2023/02/14/HVPWFqh7Gwstz1J.png" alt="分支部署"></p>
<p>在构建设置中，其实只要指定构建命令与用于上传的构建目录，这部分的配置自然上面的github workflow其实是一模一样的。</p>
<p><img src="https://s2.loli.net/2023/02/14/ZantFJBoziTp5XS.png" alt="构建设置"></p>
<p>有一个小细节是，在github workflow中我们指定了node版本，CloudFlare Pages也支持这一点，通过环境变量的方式，你可以在这里看到更多支持的<a href="https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables" target="_blank" rel="nofollow">环境变量</a>。</p>
<p><img src="https://s2.loli.net/2023/02/14/oxYwl26eGp8daWS.png" alt="指定node版本"></p>
<h2 id="总结">总结</h2>
<p>于是，我们就实现了这样一个简单却实用的CI/CD流水线。可以看出：</p>
<ol>
<li>Github Actions其实是一个非常灵活的hook工具，可以去自定义触发各种各样有趣的任务（类似的服务还有Amazon Lambda）；</li>
<li>Github Pages是一个纯粹的静态站点托管服务，上传静态站点，它就呈现；</li>
<li>CloudFlare Pages和Vercel也是静态站点托管服务，但是它们更加注重与其他平台的集成，并通过低码的方式去完成简单的构建部署以及呈现；</li>
</ol>
<p>最终，整个博客部署的步骤如下，只有虚线的关键卡点步骤是手动操作，而其余的工作都会自动完成，很方便吧。</p>
<p><img src="https://s2.loli.net/2023/02/14/iljSW7nucVfgAF1.png" alt="优化博客部署.png"></p>
</body></html></div></div></div></div></div><div class="sc-bbd5e802-0 cbkQsN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"use-github-actions-and-cloudflare-pages-improve-blog-online-process","title":"使用Github Actions与CloudFlare Pages优化博客上线流程","date":"2023-02-14","htmlText":"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003cp\u003e在之前的文章\u003ca href=\"https://b-sirius.github.io/posts/use-nextjs-create-SSG-blog\" target=\"_blank\" rel=\"nofollow\"\u003e你的静态博客，何必是hexo\u003c/a\u003e中，我大概介绍了如何搭建一个个人静态博客，但并没有涉及要如何将其上线。\u003c/p\u003e\n\u003cp\u003e我个人的首选方案是Github Pages，因为它免费，且域名直观。\u003c/p\u003e\n\u003cp\u003e在最初的时候，要发布一篇新的博客（或者做一些功能更新），我要手动做以下几步工作：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在博客仓库（\u003ccode\u003e\u0026#x3C;username\u003e.github.io\u003c/code\u003e）切出一个本地新分支；\u003c/li\u003e\n\u003cli\u003e在分支上完成博客内容的编写；\u003c/li\u003e\n\u003cli\u003e本地运行\u003ccode\u003eyarn export\u003c/code\u003e构建，生成\u003ccode\u003e/docs\u003c/code\u003e目录（github pages只允许指定目录为根目录或docs目录）；\u003c/li\u003e\n\u003cli\u003e将更新过的代码推上远端分支；\u003c/li\u003e\n\u003cli\u003e发起PR；\u003c/li\u003e\n\u003cli\u003e合并PR；\u003c/li\u003e\n\u003cli\u003e等待Github Pages重新部署，去线上验证博客是否更新成功；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在多次不断的重复以上操作后，我意识到了几个问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e我经常忘记本地export构建，因为启动dev环境是不需要这一步的；\u003c/li\u003e\n\u003cli\u003e博客仓库同时包含了源代码与构建产物代码，如果fork\u0026#x26;clone的话，构建产物代码其实是完全没有用的；\u003c/li\u003e\n\u003cli\u003e我只有在合并了main分支后才能验证线上博客是否更新成功。如果发生了本地环境没有出现的问题，那就意味着我的线上生产环境崩掉了；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这种情形下，引入一些CI/CD工具实现\u003cstrong\u003e自动触发\u003c/strong\u003e的\u003cstrong\u003e线上构建部署\u003c/strong\u003e是常见的解决方案。我将会介绍\u003cstrong\u003eGithub Actions\u003c/strong\u003e以及\u003cstrong\u003eCloudFlare Pages\u003c/strong\u003e，看看这两个免费服务可以帮我们实现怎样的自动化。\u003c/p\u003e\n\u003cp\u003e【剧透】最终实现如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://s2.loli.net/2023/02/14/iljSW7nucVfgAF1.png\" alt=\"优化博客部署.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"github-actions\"\u003eGithub Actions\u003c/h2\u003e\n\u003cp\u003e介绍它的文章很多，因此我不打算展开。直接说它的特点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e它可以被各种各样的Github操作自动触发——比如新建分支、open PR、push到某个分支，也支持通过Github API手动触发（\u003ccode\u003eworkflow_dispatch\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003eGithub维护了一个Action市场，开发者可以使用社区贡献的Action而无需自己重新手写各种常用功能。比如获取当前的分支、指定node版本、将指定目录推送到Amazon S3。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以我将博客推送到Github Pages的workflow为例：\u003c/p\u003e\n\u003cpre class=\"language-yaml\"\u003e\u003ccode class=\"language-yaml\"\u003e\u003cspan class=\"token comment\"\u003e# .github/workflows/production.yml\u003c/span\u003e\n\u003cspan class=\"token comment\"\u003e# 所有的workflow必须放在.github/workflows目录下才能被识别，文件名会作为该workflow的名称\u003c/span\u003e\n\n\u003cspan class=\"token key atrule\"\u003ename\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e Deploy for production\n\n\u003cspan class=\"token comment\"\u003e# on指定了该workflow的触发时机\u003c/span\u003e\n\u003cspan class=\"token comment\"\u003e# 这里是指定在main分支有更新时触发（直接push或者merge进main分支都会触发该时间）\u003c/span\u003e\n\u003cspan class=\"token key atrule\"\u003eon\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"token key atrule\"\u003epush\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token key atrule\"\u003ebranches\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003e main\n\n\u003cspan class=\"token key atrule\"\u003ejobs\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e# job id\u003c/span\u003e\n  \u003cspan class=\"token key atrule\"\u003eproduction\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e# runs-on指定了运行任务的机器类型，值得一提的是，我们可以使用自己的机器（比如需要支持内网环境），更多可以去了解“self-hosted runner”\u003c/span\u003e\n    \u003cspan class=\"token key atrule\"\u003eruns-on\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e ubuntu\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003elatest\n    \u003cspan class=\"token comment\"\u003e# environment指的就是仓库设置中 Actions secrets and variables 对应的environment，用于区分变量环境\u003c/span\u003e\n    \u003cspan class=\"token key atrule\"\u003eenvironment\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e production\n\n    \u003cspan class=\"token comment\"\u003e# steps就是每个job具体的步骤\u003c/span\u003e\n    \u003cspan class=\"token key atrule\"\u003esteps\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e# uses代表了这里使用了一个社区贡献的action\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e# checkout到指定分支\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003e \u003cspan class=\"token key atrule\"\u003euses\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e actions/checkout@v3\n        \u003cspan class=\"token key atrule\"\u003ewith\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003eref\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e main\n\n      \u003cspan class=\"token comment\"\u003e# 指定node版本\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003e \u003cspan class=\"token key atrule\"\u003euses\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e actions/setup\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003enode@v3\n        \u003cspan class=\"token key atrule\"\u003ewith\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003enode-version\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e16\u003c/span\u003e\n\n      \u003cspan class=\"token comment\"\u003e# yarn install\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003e \u003cspan class=\"token key atrule\"\u003euses\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e borales/actions\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003eyarn@v4\n        \u003cspan class=\"token key atrule\"\u003ename\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e yarn install\n        \u003cspan class=\"token key atrule\"\u003ewith\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003ecmd\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e install\n\n      \u003cspan class=\"token comment\"\u003e# yarn export\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003e \u003cspan class=\"token key atrule\"\u003euses\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e borales/actions\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003eyarn@v4\n        \u003cspan class=\"token key atrule\"\u003ename\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e yarn export\n        \u003cspan class=\"token key atrule\"\u003ewith\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003ecmd\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e export\n\n      \u003cspan class=\"token comment\"\u003e# 将上一步的构建目录推动到指定仓库的指定分支\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003e \u003cspan class=\"token key atrule\"\u003ename\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e Pushes to the blog github pages\n        \u003cspan class=\"token key atrule\"\u003euses\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e cpina/github\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003eaction\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003epush\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003eto\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003eanother\u003cspan class=\"token punctuation\"\u003e-\u003c/span\u003erepository@main\n        \u003cspan class=\"token key atrule\"\u003eenv\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n          \u003cspan class=\"token comment\"\u003e# secrets在仓库settings中进行设置好，在对应的环境便可读取\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003eAPI_TOKEN_GITHUB\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e $\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e secrets.API_TOKEN_GITHUB \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"token key atrule\"\u003ewith\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003esource-directory\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'docs'\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003edestination-github-username\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'B-sirius'\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003edestination-repository-name\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'b-sirius.github.io'\u003c/span\u003e\n          \u003cspan class=\"token key atrule\"\u003etarget-branch\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e main\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e有了这样一个自动触发的工作流后，我便拆分出了博客源代码仓库。每次源代码仓库的main分支更新时，Github Actions会自动去进行构建，并将构建结果push到Github Pages使用的仓库\u003ca href=\"https://github.com/B-sirius/b-sirius.github.io\" target=\"_blank\" rel=\"nofollow\"\u003eb-sirius.github.io\u003c/a\u003e的main分支。而Github Pages也会在main更新时，自动触发部署，更新线上页面。于是我之前提到的痛点的前两个，就都解决了。\u003c/p\u003e\n\u003ch2 id=\"cloudflare-pages\"\u003eCloudFlare Pages\u003c/h2\u003e\n\u003cp\u003e于是我还剩下一个问题：如何支持测试（preview）环境？对于任何应用来说，在本地验证与生产环境发布之间，至少还需要在测试环境验证一次。Github Pages目前还没有对preview环境的官方支持（尽管应该是在\u003ca href=\"https://github.com/community/community/discussions/7730\" target=\"_blank\" rel=\"nofollow\"\u003e进展之中\u003c/a\u003e），所以我个人选择了一个简单的方案：再使用一家pages服务，如CloudFlare Pages、Vercel。他们二者都与Git有很好的集成，以下将以CloudFlare Pages为例。\u003c/p\u003e\n\u003cp\u003e注册登录关联git仓库这些都没什么好说的，都是固定流程，在这些绑定完成后，我们就需要去做一些具体的设置了。\u003c/p\u003e\n\u003cp\u003e默认情况下，CloudFlare Pages会为main分支自动部署production环境，对所有其余分支自动部署preview环境，后者正好就满足了我们的需要，而前者我不需要，于是将其设置将其关闭。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://s2.loli.net/2023/02/14/HVPWFqh7Gwstz1J.png\" alt=\"分支部署\"\u003e\u003c/p\u003e\n\u003cp\u003e在构建设置中，其实只要指定构建命令与用于上传的构建目录，这部分的配置自然上面的github workflow其实是一模一样的。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://s2.loli.net/2023/02/14/ZantFJBoziTp5XS.png\" alt=\"构建设置\"\u003e\u003c/p\u003e\n\u003cp\u003e有一个小细节是，在github workflow中我们指定了node版本，CloudFlare Pages也支持这一点，通过环境变量的方式，你可以在这里看到更多支持的\u003ca href=\"https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables\" target=\"_blank\" rel=\"nofollow\"\u003e环境变量\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://s2.loli.net/2023/02/14/oxYwl26eGp8daWS.png\" alt=\"指定node版本\"\u003e\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003e于是，我们就实现了这样一个简单却实用的CI/CD流水线。可以看出：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGithub Actions其实是一个非常灵活的hook工具，可以去自定义触发各种各样有趣的任务（类似的服务还有Amazon Lambda）；\u003c/li\u003e\n\u003cli\u003eGithub Pages是一个纯粹的静态站点托管服务，上传静态站点，它就呈现；\u003c/li\u003e\n\u003cli\u003eCloudFlare Pages和Vercel也是静态站点托管服务，但是它们更加注重与其他平台的集成，并通过低码的方式去完成简单的构建部署以及呈现；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e最终，整个博客部署的步骤如下，只有虚线的关键卡点步骤是手动操作，而其余的工作都会自动完成，很方便吧。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://s2.loli.net/2023/02/14/iljSW7nucVfgAF1.png\" alt=\"优化博客部署.png\"\u003e\u003c/p\u003e\n\u003c/body\u003e\u003c/html\u003e","description":"我个人的首选方案是Github Pages，因为它免费，且域名直观。......"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"use-github-actions-and-cloudflare-pages-improve-blog-online-process"},"buildId":"H4PWxIBNlZzCnB52z8dny","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>