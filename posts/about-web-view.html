<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="WebView的世界"/><meta property="og:title" content="WebView的世界"/><meta property="og:description" content="可能长期更新，在做WebView时遇到的一些常见问题。"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="color-scheme" content="dark light"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-165611dbf69200d4.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/332-751efa0ececa7b8e.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-2b4aeb585f50200f.js" defer=""></script><script src="/_next/static/GIjWwzmqV_zCUqfUSYb44/_buildManifest.js" defer=""></script><script src="/_next/static/GIjWwzmqV_zCUqfUSYb44/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-9d615c10-0 gPcDhw"><div class="sc-868660b6-0 hptnUW"><div class="sc-bbc62a17-1 bGsVUC"><div class="sc-bbc62a17-0 dSoHmK"><a class="sc-bbc62a17-2 gGxkic" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-bbc62a17-2 gGxkic" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f71203c5-0 cEuFcK"><h1 class="sc-f71203c5-1 BdBtZ">LWDW!</h1><p class="sc-f71203c5-2 gXENPI">Learn the work from doing the work🍺</p></div></div><div class="sc-87e76b53-0 sc-77cf2bd4-0 hkJmkj dxfnCq"><div><div class="sc-ba46d312-0 hOKWax"><div class="sc-ba46d312-2 ibvPNw">WebView的世界</div><div class="sc-ba46d312-3 hcdRzS">Posted on <!-- -->2023-12-06</div></div></div></div><div class="sc-87e76b53-0 hkJmkj"><div><div class="sc-ba46d312-1 dmDrcr"><div class="sc-e9ca5221-0 czeavQ"><p>当H5遇上WebView，我们会遇到哪些常见的需求/问题？</p>
<ol>
<li>颜色适应</li>
<li>APP调起</li>
<li>数据通信</li>
<li>兼容性</li>
</ol>
<h2 id="颜色适应">颜色适应</h2>
<p>可以细分为两种情形：</p>
<ol>
<li>APP内的同一处页面需要支持不同颜色展示，常见于APP支持设置亮色、暗色主题</li>
<li>APP内不同处用到了同一页面，但是需要该页面可支持多种主题色。常见为通用H5在多处被复用，甚至在多APP内被复用。</li>
</ol>
<h3 id="场景1">场景1：</h3>
<p>关键词：<strong><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme" target="_blank" rel="noreferrer">prefers-color-scheme</a></strong></p>
<p>通过这个媒体查询，H5可以定制一套dark样式。</p>
<p>但你就不得不问了，这个媒体查询什么时候生效？WebView可以控制么？</p>
<p>一般在默认情况下，prefers-colors-scheme会跟随系统主题生效。</p>
<p>那WebView能进一步控制么？毕竟很多的App是允许用户手动设置浅色/深色模式的。</p>
<p>答案是可以的。建议参考这两篇指南：</p>
<ul>
<li><a href="https://developer.android.com/develop/ui/views/layout/webapps/dark-theme" target="_blank" rel="noreferrer">Darken web content in WebView  | Android Developers</a></li>
<li><a href="https://useyourloaf.com/blog/supporting-dark-mode-in-wkwebview/" target="_blank" rel="noreferrer">Supporting Dark Mode In WKWebView (useyourloaf.com)</a></li>
</ul>
<p>上述指南还包含三个进阶知识点：</p>
<ol>
<li>H5增加<strong>meta tag <code>&lt;meta name=&quot;color-scheme&quot; content=&quot;dark light&quot; /&gt;</code> 可以更好的帮助APP使用正确的颜色配置。</strong></li>
<li>即使没有设置prefers-color-schema，WebView其实也支持通过算法为H5生成一套深色外观。</li>
<li>在CSS中设置<code>color-scheme</code>可以帮助滚动条、Textarea元素等自带样式的控件应用正确的外观。</li>
</ol>
<p>e.g. hacker news自动生成的深色外观：</p>
<p><img src="https://s2.loli.net/2023/12/06/Dj2iHASFUugO7ml.png" alt="hacker news1.png"/></p>
<p><img src="https://s2.loli.net/2023/12/06/ADZGqs3NMeu1wdn.png" alt="hacker news2.png"/></p>
<h2 id="场景2">场景2：</h2>
<p>场景2需要为页面做动态样式渲染，也就是说WebView需要给H5传样式参数，来得到不同的样式。</p>
<p>那么参数怎么传，以及H5怎么接收参数，怎么渲染呢？</p>
<p>其实WebView和H5之间通信是之后的话题，考虑到这里只需要WebView单向的往H5传参，最常见的想法就是：</p>
<ol>
<li>URL search parameters</li>
<li>JS bridge</li>
</ol>
<p>这些方案都行，但用它们做样式动态设置其实并不太好，因为一定会产生<strong>肉眼可见的样式变化延迟</strong>——参数的接收和生效都是在客户端进行的，JS后置，这个延迟一般能有几百毫秒。</p>
<p>更好的方案？你可能已经想到了，我个人觉得动态路由+SSR非常适合这种场景。使用动态路由就可以在服务端完成参数的接收，那么返回的HTML就是参数已经生效的版本，一切都会显得非常的丝滑。</p>
<h2 id="app调起">APP调起</h2>
<p>唤端：</p>
<ul>
<li>IOS：<!-- -->
<ul>
<li>URI Scheme，不推荐，理由有<!-- -->
<ul>
<li>无法实际判断唤端成功与否，一般通过页面计时来猜测是否成功，体验并不好</li>
<li>失败的时候，会提示不认得这个链接，看起来像个报错</li>
</ul>
</li>
<li>Universal link，目前官方最推荐的方法</li>
</ul>
</li>
<li>Android<!-- -->
<ul>
<li>URI Scheme似乎表现尚可</li>
</ul>
</li>
</ul>
<h2 id="数据通信方法互相调用">数据通信，方法互相调用</h2>
<ol>
<li>JS bridge是比较常见的方案，JS需要将方法暴露到window上，然后flutter就可以调用该方法。</li>
<li>Flutter的WebView插件<a href="https://inappwebview.dev/" target="_blank" rel="noreferrer">InAppWebview</a>，本身提供了handler进行数据通信</li>
</ol>
<h2 id="兼容性">兼容性</h2>
<p>当遇到兼容性问题的时候，首先我们关心的就是WebView内核版本。</p>
<h3 id="android">Android</h3>
<p>安卓的WebView是一个独立的组件。因此当遇到兼容问题的时候，首先要查看它的版本。</p>
<p>一般可以在设置中打开开发者模式后，找到对应的信息：</p>
<p><img src="https://s2.loli.net/2023/12/06/QBEgJOPjlVDYxMT.png" alt="WebView version.png"/></p>
<p>顺带一提，升级系统WebView的方式：</p>
<ul>
<li>大陆的安卓手机系统一般是通过升级系统版本随带更新WebView版本。</li>
<li>支持Google服务的安卓手机系统可通过Google Play单独升级系统WebView版本。</li>
</ul></div></div></div></div><div class="sc-3304c032-0 fiBoCN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"about-web-view","title":"WebView的世界","date":"2023-12-06","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    strong: \"strong\",\n    a: \"a\",\n    ul: \"ul\",\n    code: \"code\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"当H5遇上WebView，我们会遇到哪些常见的需求/问题？\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"颜色适应\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"APP调起\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"数据通信\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"兼容性\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"颜色适应\",\n      children: \"颜色适应\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以细分为两种情形：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"APP内的同一处页面需要支持不同颜色展示，常见于APP支持设置亮色、暗色主题\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"APP内不同处用到了同一页面，但是需要该页面可支持多种主题色。常见为通用H5在多处被复用，甚至在多APP内被复用。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"场景1\",\n      children: \"场景1：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"关键词：\", _jsx(_components.strong, {\n        children: _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\",\n          children: \"prefers-color-scheme\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通过这个媒体查询，H5可以定制一套dark样式。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但你就不得不问了，这个媒体查询什么时候生效？WebView可以控制么？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一般在默认情况下，prefers-colors-scheme会跟随系统主题生效。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那WebView能进一步控制么？毕竟很多的App是允许用户手动设置浅色/深色模式的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"答案是可以的。建议参考这两篇指南：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://developer.android.com/develop/ui/views/layout/webapps/dark-theme\",\n          children: \"Darken web content in WebView  | Android Developers\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://useyourloaf.com/blog/supporting-dark-mode-in-wkwebview/\",\n          children: \"Supporting Dark Mode In WKWebView (useyourloaf.com)\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"上述指南还包含三个进阶知识点：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"H5增加\", _jsxs(_components.strong, {\n          children: [\"meta tag \", _jsx(_components.code, {\n            children: \"\u003cmeta name=\\\"color-scheme\\\" content=\\\"dark light\\\" /\u003e\"\n          }), \" 可以更好的帮助APP使用正确的颜色配置。\"]\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"即使没有设置prefers-color-schema，WebView其实也支持通过算法为H5生成一套深色外观。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在CSS中设置\", _jsx(_components.code, {\n          children: \"color-scheme\"\n        }), \"可以帮助滚动条、Textarea元素等自带样式的控件应用正确的外观。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"e.g. hacker news自动生成的深色外观：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://s2.loli.net/2023/12/06/Dj2iHASFUugO7ml.png\",\n        alt: \"hacker news1.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://s2.loli.net/2023/12/06/ADZGqs3NMeu1wdn.png\",\n        alt: \"hacker news2.png\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"场景2\",\n      children: \"场景2：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"场景2需要为页面做动态样式渲染，也就是说WebView需要给H5传样式参数，来得到不同的样式。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那么参数怎么传，以及H5怎么接收参数，怎么渲染呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其实WebView和H5之间通信是之后的话题，考虑到这里只需要WebView单向的往H5传参，最常见的想法就是：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"URL search parameters\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"JS bridge\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这些方案都行，但用它们做样式动态设置其实并不太好，因为一定会产生\", _jsx(_components.strong, {\n        children: \"肉眼可见的样式变化延迟\"\n      }), \"——参数的接收和生效都是在客户端进行的，JS后置，这个延迟一般能有几百毫秒。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"更好的方案？你可能已经想到了，我个人觉得动态路由+SSR非常适合这种场景。使用动态路由就可以在服务端完成参数的接收，那么返回的HTML就是参数已经生效的版本，一切都会显得非常的丝滑。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"app调起\",\n      children: \"APP调起\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"唤端：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"IOS：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"URI Scheme，不推荐，理由有\", \"\\n\", _jsxs(_components.ul, {\n              children: [\"\\n\", _jsx(_components.li, {\n                children: \"无法实际判断唤端成功与否，一般通过页面计时来猜测是否成功，体验并不好\"\n              }), \"\\n\", _jsx(_components.li, {\n                children: \"失败的时候，会提示不认得这个链接，看起来像个报错\"\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Universal link，目前官方最推荐的方法\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Android\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"URI Scheme似乎表现尚可\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"数据通信方法互相调用\",\n      children: \"数据通信，方法互相调用\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"JS bridge是比较常见的方案，JS需要将方法暴露到window上，然后flutter就可以调用该方法。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Flutter的WebView插件\", _jsx(_components.a, {\n          href: \"https://inappwebview.dev/\",\n          children: \"InAppWebview\"\n        }), \"，本身提供了handler进行数据通信\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"兼容性\",\n      children: \"兼容性\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当遇到兼容性问题的时候，首先我们关心的就是WebView内核版本。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"android\",\n      children: \"Android\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"安卓的WebView是一个独立的组件。因此当遇到兼容问题的时候，首先要查看它的版本。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一般可以在设置中打开开发者模式后，找到对应的信息：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://s2.loli.net/2023/12/06/QBEgJOPjlVDYxMT.png\",\n        alt: \"WebView version.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"顺带一提，升级系统WebView的方式：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"大陆的安卓手机系统一般是通过升级系统版本随带更新WebView版本。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"支持Google服务的安卓手机系统可通过Google Play单独升级系统WebView版本。\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"description":"可能长期更新，在做WebView时遇到的一些常见问题。","usedCustomComponentNames":[]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"about-web-view"},"buildId":"GIjWwzmqV_zCUqfUSYb44","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>