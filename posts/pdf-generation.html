<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="PDF生成方案比较"/><meta property="og:title" content="PDF生成方案比较"/><meta property="og:description" content="PDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f164db4954bac6ec.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/332-e879213584d084bf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-1001914fc6870d3d.js" defer=""></script><script src="/_next/static/hEjS3UC5Hiba4WSgVqk4J/_buildManifest.js" defer=""></script><script src="/_next/static/hEjS3UC5Hiba4WSgVqk4J/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-b711fa3b-0 dxGMRG"><div class="sc-7fa12c98-0 iqAzDm"><div class="sc-357ac6e1-1 blSmbb"><div class="sc-357ac6e1-0 fqUBXX"><a class="sc-357ac6e1-2 gfNIvm" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-357ac6e1-2 gfNIvm" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f5ce872-0 drvesR"><h1 class="sc-f5ce872-1 jPBPjm">LWDW!</h1><p class="sc-f5ce872-2 djaGsH">Learn the work from doing the work🍺</p></div></div><div class="sc-920e94b6-0 sc-20291786-0 cMfBpD eCERES"><div><div class="sc-32c5999b-0 iFBmZi"><div class="sc-32c5999b-2 fHkOeB">PDF生成方案比较</div><div class="sc-32c5999b-3 deKveP">Posted on <!-- -->2023-02-01</div></div></div></div><div class="sc-920e94b6-0 cMfBpD"><div><div class="sc-32c5999b-1 fNXLto"><div class="sc-29ea8e37-0 bjoUyc"><div><html><head></head><body><p>PDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。</p>
<p>比如签约协议，需要体现出甲方乙方的姓名、时间、签约期限（这些信息可能被维护在CMS后台中）、水印、盖章；又比如生成财务报表，将特定时间区间的收益曲线以图表形式体现在PDF中。</p>
<p>对于这样的诉求，实现方式有多种，本文会大致讨论三种思路：后端生成PDF、前端生成粗糙PDF、前/后端生成精确PDF，比较其中的优劣，给出方案选择的建议。另外，本文会针对前端生成精确PDF进一步展开，并提供<a href="https://github.com/B-sirius/web-pdf" target="_blank" rel="nofollow">示例仓库</a>。</p>
<p>目录：</p>
<ul>
<li><a href="#%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83">方案比较</a>
<ul>
<li><a href="#%E5%90%8E%E7%AB%AF%E7%94%9F%E6%88%90pdf">后端生成PDF</a></li>
<li><a href="#%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90%E7%B2%97%E7%B3%99pdf">前端生成粗糙PDF</a>
<ul>
<li><a href="#1-pdf%E5%B0%BA%E5%AF%B8">1. PDF尺寸</a></li>
<li><a href="#2-%E5%88%86%E9%A1%B5%E9%A1%B5%E9%A6%96%E9%A1%B5%E8%84%9A">2. 分页、页首、页脚</a></li>
<li><a href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%AE%E5%BC%82">3. 客户端差异</a></li>
<li><a href="#4-%E9%A2%84%E8%A7%88%E4%B8%8D%E4%B8%80%E8%87%B4">4. 预览不一致</a></li>
<li><a href="#5-%E7%BB%93%E8%AE%BA">5. 结论</a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E7%94%9F%E6%88%90%E7%B2%BE%E7%A1%AEpdf">前/后端生成精确PDF</a>
<ul>
<li><a href="#1-%E5%AD%97%E4%BD%93%E7%BB%95%E4%B8%8D%E8%BF%87%E5%8E%BB%E7%9A%84%E5%9D%8E">1. 字体，绕不过去的坎</a></li>
<li><a href="#2-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A2%84%E8%A7%88">2. 移动端预览</a></li>
<li><a href="#3-%E6%A0%B7%E5%BC%8F">3. 样式</a></li>
</ul>
</li>
<li><a href="#%E6%8F%92%E5%85%A5%E9%9C%80%E6%B1%82%E5%9B%BE%E8%A1%A8">插入需求：图表</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h2 id="方案比较">方案比较</h2>
<h3 id="后端生成pdf">后端生成PDF</h3>
<p>后端生成PDF一直是非常常见的做法，其中主要的区别是采用怎样的PDF绘制方案。</p>
<p>对于简单的文本PDF需求，可以采用<a href="https://itextpdf.com/" target="_blank" rel="nofollow">itext</a>，通过api快速的进行文字的编写排版；</p>
<p>对于复杂一些的需求，可以考虑<a href="https://pptr.dev/" target="_blank" rel="nofollow">puppeteer</a>，这就是一个“运行在node的chrome”，所以它可以在后端虚空绘制html，并将其导出为PDF（前端思想其实很重）。</p>
<p>但后端方案再成熟，它都需要带宽成本、服务运行成本。另外在开发调试过程中，PDF的绘制结果也并不直观。</p>
<p>想空手套白狼的你，可能就想前端搞定，可以咋办？</p>
<h3 id="前端生成粗糙pdf">前端生成粗糙PDF</h3>
<p>前端生成粗糙PDF的原理其实和puppeteer很相似，我直接用真实的浏览器渲染html，将其打印为PDF不就完了么！</p>
<p>但问题有几个：</p>
<h4 id="1-pdf尺寸">1. PDF尺寸</h4>
<p>PDF的尺寸是固定的，而浏览器尺寸是善变的。A4的尺寸在物理世界是210mm×297mm，涉及到电子产业的时候，便是<strong>595 × 842 points</strong>（PostScript定义）。puppeteer的一大优势就是作为headless chrome，可以方便的指定尺寸，比如指定一个595 × 842 px，凑合也能用，但是浏览器端这么搞就有点麻烦，当然肯定也是能搞得定。</p>
<h4 id="2-分页页首页脚">2. 分页、页首、页脚</h4>
<p>默认情况下，浏览器打印网页为PDF的时候，分页是很强行的，噶你的图片、表格甚至文字就成两半了。虽然可以通过<code>page-break-after</code>之类的CSS打印属性来进行一定控制（手动分页），但想要流畅的自动分页是很麻烦的，需要结合样式定义和计算（puppeteer同样会遇到该问题）。</p>
<h4 id="3-客户端差异">3. 客户端差异</h4>
<p>客户端的不同很可能导致生成结果的不同，如字体差异。</p>
<h4 id="4-预览不一致">4. 预览不一致</h4>
<p>既然在客户端生成，很可能在下载PDF前，用户是能看到这份PDF的样子的，但下载下来的PDF往往与客户端呈现的是不一致的。毕竟我们是html转的，分页、字体、边距之类的，诸多差异了只能说。</p>
<h4 id="5-结论">5. 结论</h4>
<p>所以说呢，这种方法只建议用在很凑合的场景，否则就请继续往下看！</p>
<h3 id="前后端生成精确pdf">前/后端生成精确PDF</h3>
<p>通过上面的介绍，我们发现PDF生成的挣扎主要集中于绘制，这里是一个两难命题：</p>
<ul>
<li>
<p>采用基于api的方案，绘制并不直观。面对复杂场景可能有些痛苦（尤其是习惯于HTML语言体系的前端）</p>
</li>
<li>
<p>采用基于html的方案，绘制直观，但是难以匹配PDF的格式。</p>
</li>
</ul>
<p>有没有一种方案，绘制上类似HTML，但又完美匹配了PDF呢？！</p>
<p>隆重介绍：<a href="https://react-pdf.org/" target="_blank" rel="nofollow">react-pdf</a>，npm包是<a href="https://www.npmjs.com/package/@react-pdf/renderer" target="_blank" rel="nofollow">@react-pdf/renderer</a>（正如名字，是renderer渲染器）可不要和npm上的<a href="https://www.npmjs.com/package/react-pdf" target="_blank" rel="nofollow">react-pdf</a>（这个是pdf预览器）搞错了。</p>
<p>它的工作原理很简单：定制了各种组件，允许开发者用JSX语法进行绘制，并可以指定A4尺寸（以上面提到的points => pt为尺寸单位），提供了页首、页尾、分页等组件、属性，写起来就像是写普通的JSX，只不过呢，它可以以<strong>canvas</strong>而不是dom来做预览渲染。<a href="https://react-pdf.org/repl" target="_blank" rel="nofollow">官方demo</a>看一眼就明白了。</p>
<p><img src="https://s2.loli.net/2023/01/31/ILceZBFrHw9OsRg.png" alt="demo"></p>
<p>显然它很适合作为后端方案，React+SSR这不就来了么！</p>
<p>但我多提一句前端方案，区别不大，只是多了一些坑：</p>
<h4 id="1-字体绕不过去的坎">1. 字体，绕不过去的坎</h4>
<p>只要是搞pdf生成，字体不一致是小问题，字体缺失才是大头。为了能够让pdf支持中文，客户端加载一个中文字体文件是少不了的（放在后端这就不存在问题了）。我只说4个字：<strong>方正黑体</strong>。免费、无需授权、体积3M，在中文字体界算是顶尖的小了。</p>
<h4 id="2-移动端预览">2. 移动端预览</h4>
<p>官方提供了一个<a href="https://react-pdf.org/components#pdfviewer" target="_blank" rel="nofollow">PDFViewer</a>组件，基于Iframe来做PDF预览，但很不幸，这个组件不支持移动端。</p>
<p>但幸好我们有解决方案，还记得上面提到的非常相像的仓库<a href="https://www.npmjs.com/package/react-pdf" target="_blank" rel="nofollow">react-pdf</a>（pdf预览器）么？它正好派上了用场。简单的来说，我们现场生成了pdf，然后将其吐给了pdf预览器。具体可以直接参考<a href="https://github.com/B-sirius/web-pdf/blob/12eedf4627e3a41212f6034c04f00e0cb8870a73/src/App.js#L2" target="_blank" rel="nofollow">代码</a>。</p>
<h4 id="3-样式">3. 样式</h4>
<p>虽然<code>react-pdf</code>完全支持JSX，但是具体绘制的内容只能使用官方提供的组件，且使用官方暴露的<code>style</code>属性进行布局，其属性与React原生<code>style</code>的写法基本是一致的。只是要时刻记住，<strong>它们不会变成Dom，自然也就不支持class等样式定义方式</strong>。所以如果你喜欢一些现成的CSS三方库，如<a href="https://tailwindcss.com/" target="_blank" rel="nofollow">tailwind</a>之类的，很可惜，不能用。</p>
<h3 id="插入需求图表">插入需求：图表</h3>
<p>PDF里插图表，怎么画这个图表呢？以市面上成熟的ECharts为例，它们其实是提供了生成图片的能力的，只是注意要关闭动画。另外前端渲染与服务端渲染，会有一点点区别。</p>
<p><a href="https://github.com/B-sirius/web-pdf/blob/main/src/utils/getChartsBlobImage.js" target="_blank" rel="nofollow">示例代码</a>中展示了如何在前端去做图片的生成，其实就是先要用客户端的canvas绘制出图表（在视区外绘制），将其生成blob形式的图片，将其丢到<code>React-PDF</code>中。如果是在服务端，可以使用<a href="https://www.npmjs.com/package/node-echarts-canvas" target="_blank" rel="nofollow">node-echarts-canvas</a>一类的方案。</p>
<h2 id="总结">总结</h2>
<p>本文提供了一些PDF生成上的思路，希望能够帮助大家进行比较。最后对于前端+react-pdf的组合，俺可以提供一个示例仓库（只适配了移动端），具体可见<a href="https://github.com/B-sirius/web-pdf" target="_blank" rel="nofollow">这里</a>。</p>
</body></html></div></div></div></div></div><div class="sc-bbd5e802-0 cbkQsN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"pdf-generation","title":"PDF生成方案比较","date":"2023-02-01","htmlText":"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003cp\u003ePDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。\u003c/p\u003e\n\u003cp\u003e比如签约协议，需要体现出甲方乙方的姓名、时间、签约期限（这些信息可能被维护在CMS后台中）、水印、盖章；又比如生成财务报表，将特定时间区间的收益曲线以图表形式体现在PDF中。\u003c/p\u003e\n\u003cp\u003e对于这样的诉求，实现方式有多种，本文会大致讨论三种思路：后端生成PDF、前端生成粗糙PDF、前/后端生成精确PDF，比较其中的优劣，给出方案选择的建议。另外，本文会针对前端生成精确PDF进一步展开，并提供\u003ca href=\"https://github.com/B-sirius/web-pdf\" target=\"_blank\" rel=\"nofollow\"\u003e示例仓库\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e目录：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83\"\u003e方案比较\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%90%8E%E7%AB%AF%E7%94%9F%E6%88%90pdf\"\u003e后端生成PDF\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90%E7%B2%97%E7%B3%99pdf\"\u003e前端生成粗糙PDF\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#1-pdf%E5%B0%BA%E5%AF%B8\"\u003e1. PDF尺寸\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2-%E5%88%86%E9%A1%B5%E9%A1%B5%E9%A6%96%E9%A1%B5%E8%84%9A\"\u003e2. 分页、页首、页脚\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%AE%E5%BC%82\"\u003e3. 客户端差异\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#4-%E9%A2%84%E8%A7%88%E4%B8%8D%E4%B8%80%E8%87%B4\"\u003e4. 预览不一致\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#5-%E7%BB%93%E8%AE%BA\"\u003e5. 结论\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%89%8D%E5%90%8E%E7%AB%AF%E7%94%9F%E6%88%90%E7%B2%BE%E7%A1%AEpdf\"\u003e前/后端生成精确PDF\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#1-%E5%AD%97%E4%BD%93%E7%BB%95%E4%B8%8D%E8%BF%87%E5%8E%BB%E7%9A%84%E5%9D%8E\"\u003e1. 字体，绕不过去的坎\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A2%84%E8%A7%88\"\u003e2. 移动端预览\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#3-%E6%A0%B7%E5%BC%8F\"\u003e3. 样式\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%8F%92%E5%85%A5%E9%9C%80%E6%B1%82%E5%9B%BE%E8%A1%A8\"\u003e插入需求：图表\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%80%BB%E7%BB%93\"\u003e总结\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"方案比较\"\u003e方案比较\u003c/h2\u003e\n\u003ch3 id=\"后端生成pdf\"\u003e后端生成PDF\u003c/h3\u003e\n\u003cp\u003e后端生成PDF一直是非常常见的做法，其中主要的区别是采用怎样的PDF绘制方案。\u003c/p\u003e\n\u003cp\u003e对于简单的文本PDF需求，可以采用\u003ca href=\"https://itextpdf.com/\" target=\"_blank\" rel=\"nofollow\"\u003eitext\u003c/a\u003e，通过api快速的进行文字的编写排版；\u003c/p\u003e\n\u003cp\u003e对于复杂一些的需求，可以考虑\u003ca href=\"https://pptr.dev/\" target=\"_blank\" rel=\"nofollow\"\u003epuppeteer\u003c/a\u003e，这就是一个“运行在node的chrome”，所以它可以在后端虚空绘制html，并将其导出为PDF（前端思想其实很重）。\u003c/p\u003e\n\u003cp\u003e但后端方案再成熟，它都需要带宽成本、服务运行成本。另外在开发调试过程中，PDF的绘制结果也并不直观。\u003c/p\u003e\n\u003cp\u003e想空手套白狼的你，可能就想前端搞定，可以咋办？\u003c/p\u003e\n\u003ch3 id=\"前端生成粗糙pdf\"\u003e前端生成粗糙PDF\u003c/h3\u003e\n\u003cp\u003e前端生成粗糙PDF的原理其实和puppeteer很相似，我直接用真实的浏览器渲染html，将其打印为PDF不就完了么！\u003c/p\u003e\n\u003cp\u003e但问题有几个：\u003c/p\u003e\n\u003ch4 id=\"1-pdf尺寸\"\u003e1. PDF尺寸\u003c/h4\u003e\n\u003cp\u003ePDF的尺寸是固定的，而浏览器尺寸是善变的。A4的尺寸在物理世界是210mm×297mm，涉及到电子产业的时候，便是\u003cstrong\u003e595 × 842 points\u003c/strong\u003e（PostScript定义）。puppeteer的一大优势就是作为headless chrome，可以方便的指定尺寸，比如指定一个595 × 842 px，凑合也能用，但是浏览器端这么搞就有点麻烦，当然肯定也是能搞得定。\u003c/p\u003e\n\u003ch4 id=\"2-分页页首页脚\"\u003e2. 分页、页首、页脚\u003c/h4\u003e\n\u003cp\u003e默认情况下，浏览器打印网页为PDF的时候，分页是很强行的，噶你的图片、表格甚至文字就成两半了。虽然可以通过\u003ccode\u003epage-break-after\u003c/code\u003e之类的CSS打印属性来进行一定控制（手动分页），但想要流畅的自动分页是很麻烦的，需要结合样式定义和计算（puppeteer同样会遇到该问题）。\u003c/p\u003e\n\u003ch4 id=\"3-客户端差异\"\u003e3. 客户端差异\u003c/h4\u003e\n\u003cp\u003e客户端的不同很可能导致生成结果的不同，如字体差异。\u003c/p\u003e\n\u003ch4 id=\"4-预览不一致\"\u003e4. 预览不一致\u003c/h4\u003e\n\u003cp\u003e既然在客户端生成，很可能在下载PDF前，用户是能看到这份PDF的样子的，但下载下来的PDF往往与客户端呈现的是不一致的。毕竟我们是html转的，分页、字体、边距之类的，诸多差异了只能说。\u003c/p\u003e\n\u003ch4 id=\"5-结论\"\u003e5. 结论\u003c/h4\u003e\n\u003cp\u003e所以说呢，这种方法只建议用在很凑合的场景，否则就请继续往下看！\u003c/p\u003e\n\u003ch3 id=\"前后端生成精确pdf\"\u003e前/后端生成精确PDF\u003c/h3\u003e\n\u003cp\u003e通过上面的介绍，我们发现PDF生成的挣扎主要集中于绘制，这里是一个两难命题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e采用基于api的方案，绘制并不直观。面对复杂场景可能有些痛苦（尤其是习惯于HTML语言体系的前端）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e采用基于html的方案，绘制直观，但是难以匹配PDF的格式。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有没有一种方案，绘制上类似HTML，但又完美匹配了PDF呢？！\u003c/p\u003e\n\u003cp\u003e隆重介绍：\u003ca href=\"https://react-pdf.org/\" target=\"_blank\" rel=\"nofollow\"\u003ereact-pdf\u003c/a\u003e，npm包是\u003ca href=\"https://www.npmjs.com/package/@react-pdf/renderer\" target=\"_blank\" rel=\"nofollow\"\u003e@react-pdf/renderer\u003c/a\u003e（正如名字，是renderer渲染器）可不要和npm上的\u003ca href=\"https://www.npmjs.com/package/react-pdf\" target=\"_blank\" rel=\"nofollow\"\u003ereact-pdf\u003c/a\u003e（这个是pdf预览器）搞错了。\u003c/p\u003e\n\u003cp\u003e它的工作原理很简单：定制了各种组件，允许开发者用JSX语法进行绘制，并可以指定A4尺寸（以上面提到的points =\u003e pt为尺寸单位），提供了页首、页尾、分页等组件、属性，写起来就像是写普通的JSX，只不过呢，它可以以\u003cstrong\u003ecanvas\u003c/strong\u003e而不是dom来做预览渲染。\u003ca href=\"https://react-pdf.org/repl\" target=\"_blank\" rel=\"nofollow\"\u003e官方demo\u003c/a\u003e看一眼就明白了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://s2.loli.net/2023/01/31/ILceZBFrHw9OsRg.png\" alt=\"demo\"\u003e\u003c/p\u003e\n\u003cp\u003e显然它很适合作为后端方案，React+SSR这不就来了么！\u003c/p\u003e\n\u003cp\u003e但我多提一句前端方案，区别不大，只是多了一些坑：\u003c/p\u003e\n\u003ch4 id=\"1-字体绕不过去的坎\"\u003e1. 字体，绕不过去的坎\u003c/h4\u003e\n\u003cp\u003e只要是搞pdf生成，字体不一致是小问题，字体缺失才是大头。为了能够让pdf支持中文，客户端加载一个中文字体文件是少不了的（放在后端这就不存在问题了）。我只说4个字：\u003cstrong\u003e方正黑体\u003c/strong\u003e。免费、无需授权、体积3M，在中文字体界算是顶尖的小了。\u003c/p\u003e\n\u003ch4 id=\"2-移动端预览\"\u003e2. 移动端预览\u003c/h4\u003e\n\u003cp\u003e官方提供了一个\u003ca href=\"https://react-pdf.org/components#pdfviewer\" target=\"_blank\" rel=\"nofollow\"\u003ePDFViewer\u003c/a\u003e组件，基于Iframe来做PDF预览，但很不幸，这个组件不支持移动端。\u003c/p\u003e\n\u003cp\u003e但幸好我们有解决方案，还记得上面提到的非常相像的仓库\u003ca href=\"https://www.npmjs.com/package/react-pdf\" target=\"_blank\" rel=\"nofollow\"\u003ereact-pdf\u003c/a\u003e（pdf预览器）么？它正好派上了用场。简单的来说，我们现场生成了pdf，然后将其吐给了pdf预览器。具体可以直接参考\u003ca href=\"https://github.com/B-sirius/web-pdf/blob/12eedf4627e3a41212f6034c04f00e0cb8870a73/src/App.js#L2\" target=\"_blank\" rel=\"nofollow\"\u003e代码\u003c/a\u003e。\u003c/p\u003e\n\u003ch4 id=\"3-样式\"\u003e3. 样式\u003c/h4\u003e\n\u003cp\u003e虽然\u003ccode\u003ereact-pdf\u003c/code\u003e完全支持JSX，但是具体绘制的内容只能使用官方提供的组件，且使用官方暴露的\u003ccode\u003estyle\u003c/code\u003e属性进行布局，其属性与React原生\u003ccode\u003estyle\u003c/code\u003e的写法基本是一致的。只是要时刻记住，\u003cstrong\u003e它们不会变成Dom，自然也就不支持class等样式定义方式\u003c/strong\u003e。所以如果你喜欢一些现成的CSS三方库，如\u003ca href=\"https://tailwindcss.com/\" target=\"_blank\" rel=\"nofollow\"\u003etailwind\u003c/a\u003e之类的，很可惜，不能用。\u003c/p\u003e\n\u003ch3 id=\"插入需求图表\"\u003e插入需求：图表\u003c/h3\u003e\n\u003cp\u003ePDF里插图表，怎么画这个图表呢？以市面上成熟的ECharts为例，它们其实是提供了生成图片的能力的，只是注意要关闭动画。另外前端渲染与服务端渲染，会有一点点区别。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/B-sirius/web-pdf/blob/main/src/utils/getChartsBlobImage.js\" target=\"_blank\" rel=\"nofollow\"\u003e示例代码\u003c/a\u003e中展示了如何在前端去做图片的生成，其实就是先要用客户端的canvas绘制出图表（在视区外绘制），将其生成blob形式的图片，将其丢到\u003ccode\u003eReact-PDF\u003c/code\u003e中。如果是在服务端，可以使用\u003ca href=\"https://www.npmjs.com/package/node-echarts-canvas\" target=\"_blank\" rel=\"nofollow\"\u003enode-echarts-canvas\u003c/a\u003e一类的方案。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003e本文提供了一些PDF生成上的思路，希望能够帮助大家进行比较。最后对于前端+react-pdf的组合，俺可以提供一个示例仓库（只适配了移动端），具体可见\u003ca href=\"https://github.com/B-sirius/web-pdf\" target=\"_blank\" rel=\"nofollow\"\u003e这里\u003c/a\u003e。\u003c/p\u003e\n\u003c/body\u003e\u003c/html\u003e","description":"PDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。......"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"pdf-generation"},"buildId":"hEjS3UC5Hiba4WSgVqk4J","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>