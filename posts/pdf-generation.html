<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="PDF生成方案比较"/><meta property="og:title" content="PDF生成方案比较"/><meta property="og:description" content="PDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="color-scheme" content="dark light"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-165611dbf69200d4.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/332-e879213584d084bf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-eb76b7e3d8a9592e.js" defer=""></script><script src="/_next/static/o70uTqMIvif2jk9TTv19f/_buildManifest.js" defer=""></script><script src="/_next/static/o70uTqMIvif2jk9TTv19f/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.hkJmkj{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;border:1px solid var(--dialog-border-color);background-color:var(--dialog-bg-color);padding:1px;}/*!sc*/
.hkJmkj > div{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100%;border:1px solid #9d701d;color:#fff;padding:10px;}/*!sc*/
data-styled.g1[id="sc-87e76b53-0"]{content:"hkJmkj,"}/*!sc*/
.dxfnCq{font-size:22px;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
.dxfnCq > div{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
data-styled.g2[id="sc-77cf2bd4-0"]{content:"dxfnCq,"}/*!sc*/
.gPcDhw{--root-bg-color:#000;--dialog-bg-color:#262427;--dialog-border-color:#9d701d;--font-color:#fff;--font-highlight-color:#e7e496;--nav-color:#e76464;--blog-title-shadow:1px 1px 2px #ad0909,0 0 1em #7b3f0c,0 0 0.15em #d2ff8f;--blog-hint-shadow:1px 1px 2px #ad0909,0 0 2em #7b3f0c,0 0 0.2em #d2ff8f;background-color:var(--root-bg-color);overflow:scroll;font-family:'GillSans','Helvetica Neue',Arial,Helvetica,sans-serif;}/*!sc*/
data-styled.g3[id="sc-9d615c10-0"]{content:"gPcDhw,"}/*!sc*/
.hptnUW{max-width:960px;margin:auto;overflow:hidden;padding:40px 20px;min-height:100vh;color:var(--font-color);}/*!sc*/
data-styled.g4[id="sc-868660b6-0"]{content:"hptnUW,"}/*!sc*/
.cEuFcK{font-family:monospace;}/*!sc*/
data-styled.g5[id="sc-f71203c5-0"]{content:"cEuFcK,"}/*!sc*/
.BdBtZ{font-size:44px;margin-bottom:0;text-shadow:var(--blog-title-shadow);}/*!sc*/
data-styled.g6[id="sc-f71203c5-1"]{content:"BdBtZ,"}/*!sc*/
.gXENPI{font-size:12px;margin:0;text-shadow:var(--blog-hint-shadow);}/*!sc*/
data-styled.g7[id="sc-f71203c5-2"]{content:"gXENPI,"}/*!sc*/
.dSoHmK{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;margin-bottom:20px;}/*!sc*/
data-styled.g8[id="sc-bbc62a17-0"]{content:"dSoHmK,"}/*!sc*/
.bGsVUC{margin-bottom:50px;}/*!sc*/
data-styled.g9[id="sc-bbc62a17-1"]{content:"bGsVUC,"}/*!sc*/
.gGxkic{padding:5px 0;font-family:monospace;color:var(--font-color);font-size:20px;margin-right:20px;}/*!sc*/
.gGxkic:hover{cursor:pointer;}/*!sc*/
@media only screen and (max-width:500px){.gGxkic{font-size:18px;margin-right:10px;}}/*!sc*/
data-styled.g10[id="sc-bbc62a17-2"]{content:"gGxkic,"}/*!sc*/
.bMRVsR{padding:5px 0;font-family:monospace;color:var(--font-color);font-size:20px;margin-right:20px;}/*!sc*/
.bMRVsR:hover{cursor:pointer;}/*!sc*/
@media only screen and (max-width:500px){.bMRVsR{font-size:18px;margin-right:10px;}}/*!sc*/
data-styled.g11[id="sc-bbc62a17-3"]{content:"bMRVsR,"}/*!sc*/
.hoKJKn{--md-link-color:#e64f4f;--md-title-shadow:1px 1px 2px #ad0909,0 0 1em #7b3f0c,0 0 0.2em #d2ff8f;--md-title-color:#f2f2f2;--md-sub-title-color:#d3dae1;}/*!sc*/
.hoKJKn h2{font-size:30px;margin-top:50px;margin-bottom:0;text-shadow:var(--md-title-shadow);color:var(--md-title-color);}/*!sc*/
.hoKJKn h3{font-size:26px;margin-bottom:0;color:var(--md-sub-title-color);}/*!sc*/
.hoKJKn h4,.hoKJKn h5,.hoKJKn h6{font-size:24px;color:var(--md-sub-title-color);}/*!sc*/
.hoKJKn p{margin-bottom:2em;}/*!sc*/
.hoKJKn p,.hoKJKn li,.hoKJKn a{font-size:18px;line-height:32px;}/*!sc*/
.hoKJKn a{color:var(--md-link-color);}/*!sc*/
.hoKJKn img{max-width:100%;}/*!sc*/
.hoKJKn hr{border-color:#111;}/*!sc*/
.hoKJKn blockquote{border-left:5px solid rgb(52,57,59);background-color:rgb(54,0,0);margin:0;padding:1em 1.5em 1em 2em;}/*!sc*/
.hoKJKn blockquote p,.hoKJKn blockquote li{margin:0;}/*!sc*/
.hoKJKn code{font-size:16.5px;background-color:rgba(115,125,140,0.17);padding:4.5px 6px;border-radius:3px;}/*!sc*/
.hoKJKn pre code{background-color:transparent;padding:0;border-radius:none;}/*!sc*/
@media only screen and (max-width:500px){.hoKJKn p,.hoKJKn li,.hoKJKn a{font-size:16px;line-height:30px;}.hoKJKn code{font-size:14px;}}/*!sc*/
data-styled.g12[id="sc-ac90742c-0"]{content:"hoKJKn,"}/*!sc*/
.fiBoCN{margin-top:50px;}/*!sc*/
data-styled.g13[id="sc-3304c032-0"]{content:"fiBoCN,"}/*!sc*/
.hOKWax{padding:0px 20px 10px;}/*!sc*/
@media only screen and (max-width:500px){.hOKWax{padding:0 5px 10px;}}/*!sc*/
data-styled.g14[id="sc-ba46d312-0"]{content:"hOKWax,"}/*!sc*/
.dmDrcr{padding:20px 20px;}/*!sc*/
@media only screen and (max-width:500px){.dmDrcr{padding:5px 5px;}}/*!sc*/
data-styled.g15[id="sc-ba46d312-1"]{content:"dmDrcr,"}/*!sc*/
.ibvPNw{font-size:40px;color:var(--font-highlight-color);margin-bottom:5px;}/*!sc*/
data-styled.g16[id="sc-ba46d312-2"]{content:"ibvPNw,"}/*!sc*/
.hcdRzS{font-family:monospace;font-size:14px;}/*!sc*/
data-styled.g17[id="sc-ba46d312-3"]{content:"hcdRzS,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-9d615c10-0 gPcDhw"><div class="sc-868660b6-0 hptnUW"><div class="sc-bbc62a17-1 bGsVUC"><div class="sc-bbc62a17-0 dSoHmK"><a class="sc-bbc62a17-2 gGxkic" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-bbc62a17-2 gGxkic" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f71203c5-0 cEuFcK"><h1 class="sc-f71203c5-1 BdBtZ">LWDW!</h1><p class="sc-f71203c5-2 gXENPI">Learn the work from doing the work🍺</p></div></div><div class="sc-87e76b53-0 sc-77cf2bd4-0 hkJmkj dxfnCq"><div><div class="sc-ba46d312-0 hOKWax"><div class="sc-ba46d312-2 ibvPNw">PDF生成方案比较</div><div class="sc-ba46d312-3 hcdRzS">Posted on <!-- -->2023-02-01</div></div></div></div><div class="sc-87e76b53-0 hkJmkj"><div><div class="sc-ba46d312-1 dmDrcr"><div class="sc-ac90742c-0 hoKJKn"><p>PDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。</p>
<p>比如签约协议，需要体现出甲方乙方的姓名、时间、签约期限（这些信息可能被维护在CMS后台中）、水印、盖章；又比如生成财务报表，将特定时间区间的收益曲线以图表形式体现在PDF中。</p>
<p>对于这样的诉求，实现方式有多种，本文会大致讨论三种思路：后端生成PDF、前端生成粗糙PDF、前/后端生成精确PDF，比较其中的优劣，给出方案选择的建议。另外，本文会针对前端生成精确PDF进一步展开，并提供<a href="https://github.com/B-sirius/web-pdf" target="_blank" rel="noreferrer">示例仓库</a>。</p>
<h2 id="方案比较">方案比较</h2>
<h3 id="后端生成pdf">后端生成PDF</h3>
<p>后端生成PDF一直是非常常见的做法，其中主要的区别是采用怎样的PDF绘制方案。</p>
<p>对于简单的文本PDF需求，可以采用<a href="https://itextpdf.com/" target="_blank" rel="noreferrer">itext</a>，通过api快速的进行文字的编写排版；</p>
<p>对于复杂一些的需求，可以考虑<a href="https://pptr.dev/" target="_blank" rel="noreferrer">puppeteer</a>，这就是一个“运行在node的chrome”，所以它可以在后端虚空绘制html，并将其导出为PDF（前端思想其实很重）。</p>
<p>但后端方案再成熟，它都需要带宽成本、服务运行成本。另外在开发调试过程中，PDF的绘制结果也并不直观。</p>
<p>想空手套白狼的你，可能就想前端搞定，可以咋办？</p>
<h3 id="前端生成粗糙pdf">前端生成粗糙PDF</h3>
<p>前端生成粗糙PDF的原理其实和puppeteer很相似，我直接用真实的浏览器渲染html，将其打印为PDF不就完了么！</p>
<p>但问题有几个：</p>
<h4 id="1-pdf尺寸">1. PDF尺寸</h4>
<p>PDF的尺寸是固定的，而浏览器尺寸是善变的。A4的尺寸在物理世界是210mm×297mm，涉及到电子产业的时候，便是<strong>595 × 842 points</strong>（PostScript定义）。puppeteer的一大优势就是作为headless chrome，可以方便的指定尺寸，比如指定一个595 × 842 px，凑合也能用，但是浏览器端这么搞就有点麻烦，当然肯定也是能搞得定。</p>
<h4 id="2-分页页首页脚">2. 分页、页首、页脚</h4>
<p>默认情况下，浏览器打印网页为PDF的时候，分页是很强行的，噶你的图片、表格甚至文字就成两半了。虽然可以通过<code>page-break-after</code>之类的CSS打印属性来进行一定控制（手动分页），但想要流畅的自动分页是很麻烦的，需要结合样式定义和计算（puppeteer同样会遇到该问题）。</p>
<h4 id="3-客户端差异">3. 客户端差异</h4>
<p>客户端的不同很可能导致生成结果的不同，如字体差异。</p>
<h4 id="4-预览不一致">4. 预览不一致</h4>
<p>既然在客户端生成，很可能在下载PDF前，用户是能看到这份PDF的样子的，但下载下来的PDF往往与客户端呈现的是不一致的。毕竟我们是html转的，分页、字体、边距之类的，诸多差异了只能说。</p>
<h4 id="5-结论">5. 结论</h4>
<p>所以说呢，这种方法只建议用在很凑合的场景，否则就请继续往下看！</p>
<h3 id="前后端生成精确pdf">前/后端生成精确PDF</h3>
<p>通过上面的介绍，我们发现PDF生成的挣扎主要集中于绘制，这里是一个两难命题：</p>
<ul>
<li>
<p>采用基于api的方案，绘制并不直观。面对复杂场景可能有些痛苦（尤其是习惯于HTML语言体系的前端）</p>
</li>
<li>
<p>采用基于html的方案，绘制直观，但是难以匹配PDF的格式。</p>
</li>
</ul>
<p>有没有一种方案，绘制上类似HTML，但又完美匹配了PDF呢？！</p>
<p>隆重介绍：<a href="https://react-pdf.org/" target="_blank" rel="noreferrer">react-pdf</a>，npm包是<a href="https://www.npmjs.com/package/@react-pdf/renderer" target="_blank" rel="noreferrer">@react-pdf/renderer</a>（正如名字，是renderer渲染器）可不要和npm上的<a href="https://www.npmjs.com/package/react-pdf" target="_blank" rel="noreferrer">react-pdf</a>（这个是pdf预览器）搞错了。</p>
<p>它的工作原理很简单：定制了各种组件，允许开发者用JSX语法进行绘制，并可以指定A4尺寸（以上面提到的points =&gt; pt为尺寸单位），提供了页首、页尾、分页等组件、属性，写起来就像是写普通的JSX，只不过呢，它可以以<strong>canvas</strong>而不是dom来做预览渲染。<a href="https://react-pdf.org/repl" target="_blank" rel="noreferrer">官方demo</a>看一眼就明白了。</p>
<p><img src="https://s2.loli.net/2023/01/31/ILceZBFrHw9OsRg.png" alt="demo"/></p>
<p>显然它很适合作为后端方案，React+SSR这不就来了么！</p>
<p>但我多提一句前端方案，区别不大，只是多了一些坑：</p>
<h4 id="1-字体绕不过去的坎">1. 字体，绕不过去的坎</h4>
<p>只要是搞pdf生成，字体不一致是小问题，字体缺失才是大头。为了能够让pdf支持中文，客户端加载一个中文字体文件是少不了的（放在后端这就不存在问题了）。我只说4个字：<strong>方正黑体</strong>。免费、无需授权、体积3M，在中文字体界算是顶尖的小了。</p>
<h4 id="2-移动端预览">2. 移动端预览</h4>
<p>官方提供了一个<a href="https://react-pdf.org/components#pdfviewer" target="_blank" rel="noreferrer">PDFViewer</a>组件，基于Iframe来做PDF预览，但很不幸，这个组件不支持移动端。</p>
<p>但幸好我们有解决方案，还记得上面提到的非常相像的仓库<a href="https://www.npmjs.com/package/react-pdf" target="_blank" rel="noreferrer">react-pdf</a>（pdf预览器）么？它正好派上了用场。简单的来说，我们现场生成了pdf，然后将其吐给了pdf预览器。具体可以直接参考<a href="https://github.com/B-sirius/web-pdf/blob/12eedf4627e3a41212f6034c04f00e0cb8870a73/src/App.js#L2" target="_blank" rel="noreferrer">代码</a>。</p>
<h4 id="3-样式">3. 样式</h4>
<p>虽然<code>react-pdf</code>完全支持JSX，但是具体绘制的内容只能使用官方提供的组件，且使用官方暴露的<code>style</code>属性进行布局，其属性与React原生<code>style</code>的写法基本是一致的。只是要时刻记住，<strong>它们不会变成Dom，自然也就不支持class等样式定义方式</strong>。所以如果你喜欢一些现成的CSS三方库，如<a href="https://tailwindcss.com/" target="_blank" rel="noreferrer">tailwind</a>之类的，很可惜，不能用。</p>
<h3 id="插入需求图表">插入需求：图表</h3>
<p>PDF里插图表，怎么画这个图表呢？以市面上成熟的ECharts为例，它们其实是提供了生成图片的能力的，只是注意要关闭动画。另外前端渲染与服务端渲染，会有一点点区别。</p>
<p><a href="https://github.com/B-sirius/web-pdf/blob/main/src/utils/getChartsBlobImage.js" target="_blank" rel="noreferrer">示例代码</a>中展示了如何在前端去做图片的生成，其实就是先要用客户端的canvas绘制出图表（在视区外绘制），将其生成blob形式的图片，将其丢到<code>React-PDF</code>中。如果是在服务端，可以使用<a href="https://www.npmjs.com/package/node-echarts-canvas" target="_blank" rel="noreferrer">node-echarts-canvas</a>一类的方案。</p>
<h2 id="总结">总结</h2>
<p>本文提供了一些PDF生成上的思路，希望能够帮助大家进行比较。最后对于前端+react-pdf的组合，俺可以提供一个示例仓库（只适配了移动端），具体可见<a href="https://github.com/B-sirius/web-pdf" target="_blank" rel="noreferrer">这里</a>。</p></div></div></div></div><div class="sc-3304c032-0 fiBoCN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"pdf-generation","title":"PDF生成方案比较","date":"2023-02-01","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    strong: \"strong\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"PDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"比如签约协议，需要体现出甲方乙方的姓名、时间、签约期限（这些信息可能被维护在CMS后台中）、水印、盖章；又比如生成财务报表，将特定时间区间的收益曲线以图表形式体现在PDF中。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"对于这样的诉求，实现方式有多种，本文会大致讨论三种思路：后端生成PDF、前端生成粗糙PDF、前/后端生成精确PDF，比较其中的优劣，给出方案选择的建议。另外，本文会针对前端生成精确PDF进一步展开，并提供\", _jsx(_components.a, {\n        href: \"https://github.com/B-sirius/web-pdf\",\n        children: \"示例仓库\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"方案比较\",\n      children: \"方案比较\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"后端生成pdf\",\n      children: \"后端生成PDF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"后端生成PDF一直是非常常见的做法，其中主要的区别是采用怎样的PDF绘制方案。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"对于简单的文本PDF需求，可以采用\", _jsx(_components.a, {\n        href: \"https://itextpdf.com/\",\n        children: \"itext\"\n      }), \"，通过api快速的进行文字的编写排版；\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"对于复杂一些的需求，可以考虑\", _jsx(_components.a, {\n        href: \"https://pptr.dev/\",\n        children: \"puppeteer\"\n      }), \"，这就是一个“运行在node的chrome”，所以它可以在后端虚空绘制html，并将其导出为PDF（前端思想其实很重）。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但后端方案再成熟，它都需要带宽成本、服务运行成本。另外在开发调试过程中，PDF的绘制结果也并不直观。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"想空手套白狼的你，可能就想前端搞定，可以咋办？\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"前端生成粗糙pdf\",\n      children: \"前端生成粗糙PDF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"前端生成粗糙PDF的原理其实和puppeteer很相似，我直接用真实的浏览器渲染html，将其打印为PDF不就完了么！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但问题有几个：\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"1-pdf尺寸\",\n      children: \"1. PDF尺寸\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"PDF的尺寸是固定的，而浏览器尺寸是善变的。A4的尺寸在物理世界是210mm×297mm，涉及到电子产业的时候，便是\", _jsx(_components.strong, {\n        children: \"595 × 842 points\"\n      }), \"（PostScript定义）。puppeteer的一大优势就是作为headless chrome，可以方便的指定尺寸，比如指定一个595 × 842 px，凑合也能用，但是浏览器端这么搞就有点麻烦，当然肯定也是能搞得定。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"2-分页页首页脚\",\n      children: \"2. 分页、页首、页脚\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"默认情况下，浏览器打印网页为PDF的时候，分页是很强行的，噶你的图片、表格甚至文字就成两半了。虽然可以通过\", _jsx(_components.code, {\n        children: \"page-break-after\"\n      }), \"之类的CSS打印属性来进行一定控制（手动分页），但想要流畅的自动分页是很麻烦的，需要结合样式定义和计算（puppeteer同样会遇到该问题）。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"3-客户端差异\",\n      children: \"3. 客户端差异\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"客户端的不同很可能导致生成结果的不同，如字体差异。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"4-预览不一致\",\n      children: \"4. 预览不一致\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然在客户端生成，很可能在下载PDF前，用户是能看到这份PDF的样子的，但下载下来的PDF往往与客户端呈现的是不一致的。毕竟我们是html转的，分页、字体、边距之类的，诸多差异了只能说。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"5-结论\",\n      children: \"5. 结论\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以说呢，这种方法只建议用在很凑合的场景，否则就请继续往下看！\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"前后端生成精确pdf\",\n      children: \"前/后端生成精确PDF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通过上面的介绍，我们发现PDF生成的挣扎主要集中于绘制，这里是一个两难命题：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"采用基于api的方案，绘制并不直观。面对复杂场景可能有些痛苦（尤其是习惯于HTML语言体系的前端）\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"采用基于html的方案，绘制直观，但是难以匹配PDF的格式。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有没有一种方案，绘制上类似HTML，但又完美匹配了PDF呢？！\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"隆重介绍：\", _jsx(_components.a, {\n        href: \"https://react-pdf.org/\",\n        children: \"react-pdf\"\n      }), \"，npm包是\", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/@react-pdf/renderer\",\n        children: \"@react-pdf/renderer\"\n      }), \"（正如名字，是renderer渲染器）可不要和npm上的\", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/react-pdf\",\n        children: \"react-pdf\"\n      }), \"（这个是pdf预览器）搞错了。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"它的工作原理很简单：定制了各种组件，允许开发者用JSX语法进行绘制，并可以指定A4尺寸（以上面提到的points =\u003e pt为尺寸单位），提供了页首、页尾、分页等组件、属性，写起来就像是写普通的JSX，只不过呢，它可以以\", _jsx(_components.strong, {\n        children: \"canvas\"\n      }), \"而不是dom来做预览渲染。\", _jsx(_components.a, {\n        href: \"https://react-pdf.org/repl\",\n        children: \"官方demo\"\n      }), \"看一眼就明白了。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://s2.loli.net/2023/01/31/ILceZBFrHw9OsRg.png\",\n        alt: \"demo\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"显然它很适合作为后端方案，React+SSR这不就来了么！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但我多提一句前端方案，区别不大，只是多了一些坑：\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"1-字体绕不过去的坎\",\n      children: \"1. 字体，绕不过去的坎\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只要是搞pdf生成，字体不一致是小问题，字体缺失才是大头。为了能够让pdf支持中文，客户端加载一个中文字体文件是少不了的（放在后端这就不存在问题了）。我只说4个字：\", _jsx(_components.strong, {\n        children: \"方正黑体\"\n      }), \"。免费、无需授权、体积3M，在中文字体界算是顶尖的小了。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"2-移动端预览\",\n      children: \"2. 移动端预览\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"官方提供了一个\", _jsx(_components.a, {\n        href: \"https://react-pdf.org/components#pdfviewer\",\n        children: \"PDFViewer\"\n      }), \"组件，基于Iframe来做PDF预览，但很不幸，这个组件不支持移动端。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但幸好我们有解决方案，还记得上面提到的非常相像的仓库\", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/react-pdf\",\n        children: \"react-pdf\"\n      }), \"（pdf预览器）么？它正好派上了用场。简单的来说，我们现场生成了pdf，然后将其吐给了pdf预览器。具体可以直接参考\", _jsx(_components.a, {\n        href: \"https://github.com/B-sirius/web-pdf/blob/12eedf4627e3a41212f6034c04f00e0cb8870a73/src/App.js#L2\",\n        children: \"代码\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"3-样式\",\n      children: \"3. 样式\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"虽然\", _jsx(_components.code, {\n        children: \"react-pdf\"\n      }), \"完全支持JSX，但是具体绘制的内容只能使用官方提供的组件，且使用官方暴露的\", _jsx(_components.code, {\n        children: \"style\"\n      }), \"属性进行布局，其属性与React原生\", _jsx(_components.code, {\n        children: \"style\"\n      }), \"的写法基本是一致的。只是要时刻记住，\", _jsx(_components.strong, {\n        children: \"它们不会变成Dom，自然也就不支持class等样式定义方式\"\n      }), \"。所以如果你喜欢一些现成的CSS三方库，如\", _jsx(_components.a, {\n        href: \"https://tailwindcss.com/\",\n        children: \"tailwind\"\n      }), \"之类的，很可惜，不能用。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"插入需求图表\",\n      children: \"插入需求：图表\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"PDF里插图表，怎么画这个图表呢？以市面上成熟的ECharts为例，它们其实是提供了生成图片的能力的，只是注意要关闭动画。另外前端渲染与服务端渲染，会有一点点区别。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://github.com/B-sirius/web-pdf/blob/main/src/utils/getChartsBlobImage.js\",\n        children: \"示例代码\"\n      }), \"中展示了如何在前端去做图片的生成，其实就是先要用客户端的canvas绘制出图表（在视区外绘制），将其生成blob形式的图片，将其丢到\", _jsx(_components.code, {\n        children: \"React-PDF\"\n      }), \"中。如果是在服务端，可以使用\", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/node-echarts-canvas\",\n        children: \"node-echarts-canvas\"\n      }), \"一类的方案。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"总结\",\n      children: \"总结\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"本文提供了一些PDF生成上的思路，希望能够帮助大家进行比较。最后对于前端+react-pdf的组合，俺可以提供一个示例仓库（只适配了移动端），具体可见\", _jsx(_components.a, {\n        href: \"https://github.com/B-sirius/web-pdf\",\n        children: \"这里\"\n      }), \"。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"description":"PDF生成是一个常见的需求，目的一般是将动态数据插入到特定格式的PDF模版中。......","usedCustomComponentNames":[]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"pdf-generation"},"buildId":"o70uTqMIvif2jk9TTv19f","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>