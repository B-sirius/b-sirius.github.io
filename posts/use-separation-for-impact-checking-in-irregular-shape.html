<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="弹一弹#3 分离轴定理拯救碰撞检测！"/><meta property="og:title" content="弹一弹#3 分离轴定理拯救碰撞检测！"/><meta property="og:description" content="之前在准备高考，没有更新；今天高考开始了，我决定不考了来更新嗯嗯【嗯？？？】......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-165611dbf69200d4.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/332-e879213584d084bf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-bdcbd70cb4cfba17.js" defer=""></script><script src="/_next/static/31YAT_9sJuwKyhid7c4j7/_buildManifest.js" defer=""></script><script src="/_next/static/31YAT_9sJuwKyhid7c4j7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-9d615c10-0 gPcDhw"><div class="sc-868660b6-0 hptnUW"><div class="sc-bbc62a17-1 bGsVUC"><div class="sc-bbc62a17-0 dSoHmK"><a class="sc-bbc62a17-2 gGxkic" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-bbc62a17-2 gGxkic" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f71203c5-0 cEuFcK"><h1 class="sc-f71203c5-1 BdBtZ">LWDW!</h1><p class="sc-f71203c5-2 gXENPI">Learn the work from doing the work🍺</p></div></div><div class="sc-87e76b53-0 sc-77cf2bd4-0 hkJmkj dxfnCq"><div><div class="sc-ba46d312-0 hOKWax"><div class="sc-ba46d312-2 ibvPNw">弹一弹#3 分离轴定理拯救碰撞检测！</div><div class="sc-ba46d312-3 hcdRzS">Posted on <!-- -->2018-06-07</div></div></div></div><div class="sc-87e76b53-0 hkJmkj"><div><div class="sc-ba46d312-1 dmDrcr"><div class="sc-e9ca5221-0 czeavQ"><p>之前在准备高考，没有更新；今天高考开始了，我决定不考了来更新嗯嗯【嗯？？？】</p>
<hr/>
<p>之前俺们聊了一下圆与矩形的碰撞检测，说实话还是比较讨巧的，充分利用了在限定条件下的他们的特殊图形性质。然而有简单的情形就有蛋疼的情形，面对不规则的多边形，该如何考虑进行检测嘞？</p>
<h2 id="聚光灯上场">聚光灯上场！</h2>
<p>让我们想象二维世界里有两个分离的（凸）多边形，四周是墙，如果我们用一个聚光灯（其实平行光源更合适啦）环绕它们去照射，那么肯定存在某个角度，它们的投影是分离的！这就是俺们这次所要使用的算法——分离轴定理！！</p>
<h2 id="抽象实现">抽象实现</h2>
<p>在具体实现时，俺们需要考虑这几个问题</p>
<ul>
<li>我们最少需要哪些聚光灯位——如何确定投影轴</li>
<li>如何得到影子——如何将多边形投影到投影轴上</li>
<li>怎么判断影子是否重叠——怎么判断投影是否重叠</li>
</ul>
<h3 id="确定投影轴">确定投影轴</h3>
<p>由于凸多边形本身的特点，易证（嗯有意见？）我们只需要将光线平行于多边形的每条边进行投影就行；换句话说，所有需要检测的投影轴就是多边形的边缘法向量⬇️，CD便是一个边缘向量，IH就是它的边缘法向量。显然对于向量位置是无所谓的，直线GF的方向与向量IH平行，更有利于理解投影嗯嗯。</p>
<p><img src="https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/%E5%88%86%E7%A6%BB%E8%BD%B4_%E8%BE%B9%E7%BC%98%E6%B3%95%E5%90%91%E9%87%8F.png" alt="边缘法向量"/></p>
<h3 id="如何确定投影的大小及它们是否重叠">如何确定投影的大小及它们是否重叠</h3>
<p>这是卡了我很久的一个问题，首先看图好吧，大家都很喜欢看图我明白</p>
<p>这里的投影轴是BC的法向量，正好是一个符合投影不重叠的投影轴（三角形的投影为JL，四边形的投影为MN）。对于人脑来说，我们可以一眼看出它们不重叠的事实，但是我们该如何将其抽象到程序中呢————？如何记录J，L以及M，N（事实上由于每条边都要投影，还有很多没标出来的点需要记录）并判断它们组成的线段是否重叠？对于我萎缩的大脑，有点蛋疼......</p>
<p><img src="https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/%E5%88%86%E7%A6%BB%E8%BD%B4_%E4%B8%8D%E9%87%8D%E5%8F%A0.png" alt="不重叠"/></p>
<h3 id="原点登场">原点登场</h3>
<p>不要忘了我们的坐标系，要知道我们在程序中所使用的<strong>向量、顶点</strong>都是按照坐标系的思路来抽象的，对于每个顶点（x, y），坐标都是相对于原点的！因此对于上图，与其试图投影<strong>线段AB</strong>到投影轴得到<strong>投影JL</strong>，我们可以将其看作<strong>原点H与顶点B</strong>投影得到<strong>投影KL</strong>、<strong>原点H与顶点A</strong>投影得到<strong>投影KJ</strong>，其他顶点类似——想要得到多边形的投影，只要得到<strong>顶点投影到投影轴后相对于原点投影到投影轴的位置的“距离”（可正可负），相对最大最小值便可代表这个投影</strong>。而这个相对值也甚至几乎是现成的：<strong>原点到顶点的向量点乘边缘法向量便可（显然，为了结果有可比性，边缘法向量的大小必须固定，一般normalize大小为1）</strong>，点乘的意义我相信大家也明白，就不赘述了。在比较两个多边形的投影时，其实比较的也是这样一个投影顶点相对投影原点的值。</p>
<h3 id="小小的经验">小小的经验</h3>
<p>如果觉得上文概念混淆，那就对了！投影就是投影，是我们想到的最直观的比较方法。然而我们的目的只是<strong>借助投影比较多边形是否重叠，而不是投影本身</strong>，因此我们没有抽象出一个<strong>直观的代表投影的数据结构</strong>（比如用两个坐标表示？），而是<strong>借助原点与投影性质抽象出一个尽管不是投影，却更容易比较的结构</strong>，在我的代码里它是这样的：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">/* 
    投影，
    用min和max来记录，
    因为实际上是顶点与原点构成的线段在轴上的投影，
    因为顶点的投影位置是固定的，
    所以比较时只需要考虑投影的“长度”（可以为负），
    min和max分别是一个多边形的所有顶点（与原点）投影长度的最小与最大值
*/</span>
<span class="token keyword">class</span> <span class="token class-name">Projection</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">min<span class="token punctuation">,</span> max</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">min</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">max</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">overlaps</span><span class="token punctuation">(</span><span class="token parameter">pro</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">max</span> <span class="token operator">&gt;</span> pro<span class="token punctuation">.</span><span class="token property-access">min</span> <span class="token operator">&amp;&amp;</span> pro<span class="token punctuation">.</span><span class="token property-access">max</span> <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">min</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="成品">成品</h2>
<p>俺的<a href="https://codepen.io/padfoot_07/full/pKyOYm" target="_blank" rel="noreferrer">分离轴实现</a>，比较核心的部分就是<code>Polygon对象的project、getNormals实现与Projection对象实现</code></p>
<p data-height="265" data-theme-id="0" data-slug-hash="pKyOYm" data-default-tab="js,result" data-user="padfoot_07" data-embed-version="2" data-pen-title="分离轴-碰撞检测" class="codepen">See the Pen <a href="https://codepen.io/padfoot_07/pen/pKyOYm/">分离轴-碰撞检测</a> by Zhouyi (<a href="https://codepen.io/padfoot_07">@padfoot_07</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async="" src="https://static.codepen.io/assets/embed/ei.js"></script>
<hr/>
<p>今天是高考，又有很多人将要步入新一阶段的学习。感觉大家在学习中总是关注到很多很了不起的方面，却对于自己的生活方式没有认真的思考过呢。“赞美太阳！”虽是游戏中看似有些搞笑的台词，实际上对于个人来说，意味却是很认真的啊。（......我看你是传火传的活尸化严重了）</p></div></div></div></div><div class="sc-3304c032-0 fiBoCN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"use-separation-for-impact-checking-in-irregular-shape","title":"弹一弹#3 分离轴定理拯救碰撞检测！","date":"2018-06-07","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    hr: \"hr\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    img: \"img\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"之前在准备高考，没有更新；今天高考开始了，我决定不考了来更新嗯嗯【嗯？？？】\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"之前俺们聊了一下圆与矩形的碰撞检测，说实话还是比较讨巧的，充分利用了在限定条件下的他们的特殊图形性质。然而有简单的情形就有蛋疼的情形，面对不规则的多边形，该如何考虑进行检测嘞？\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"聚光灯上场\",\n      children: \"聚光灯上场！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"让我们想象二维世界里有两个分离的（凸）多边形，四周是墙，如果我们用一个聚光灯（其实平行光源更合适啦）环绕它们去照射，那么肯定存在某个角度，它们的投影是分离的！这就是俺们这次所要使用的算法——分离轴定理！！\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"抽象实现\",\n      children: \"抽象实现\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在具体实现时，俺们需要考虑这几个问题\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"我们最少需要哪些聚光灯位——如何确定投影轴\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"如何得到影子——如何将多边形投影到投影轴上\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"怎么判断影子是否重叠——怎么判断投影是否重叠\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"确定投影轴\",\n      children: \"确定投影轴\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由于凸多边形本身的特点，易证（嗯有意见？）我们只需要将光线平行于多边形的每条边进行投影就行；换句话说，所有需要检测的投影轴就是多边形的边缘法向量⬇️，CD便是一个边缘向量，IH就是它的边缘法向量。显然对于向量位置是无所谓的，直线GF的方向与向量IH平行，更有利于理解投影嗯嗯。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/%E5%88%86%E7%A6%BB%E8%BD%B4_%E8%BE%B9%E7%BC%98%E6%B3%95%E5%90%91%E9%87%8F.png\",\n        alt: \"边缘法向量\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"如何确定投影的大小及它们是否重叠\",\n      children: \"如何确定投影的大小及它们是否重叠\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这是卡了我很久的一个问题，首先看图好吧，大家都很喜欢看图我明白\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这里的投影轴是BC的法向量，正好是一个符合投影不重叠的投影轴（三角形的投影为JL，四边形的投影为MN）。对于人脑来说，我们可以一眼看出它们不重叠的事实，但是我们该如何将其抽象到程序中呢————？如何记录J，L以及M，N（事实上由于每条边都要投影，还有很多没标出来的点需要记录）并判断它们组成的线段是否重叠？对于我萎缩的大脑，有点蛋疼......\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/%E5%88%86%E7%A6%BB%E8%BD%B4_%E4%B8%8D%E9%87%8D%E5%8F%A0.png\",\n        alt: \"不重叠\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"原点登场\",\n      children: \"原点登场\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"不要忘了我们的坐标系，要知道我们在程序中所使用的\", _jsx(_components.strong, {\n        children: \"向量、顶点\"\n      }), \"都是按照坐标系的思路来抽象的，对于每个顶点（x, y），坐标都是相对于原点的！因此对于上图，与其试图投影\", _jsx(_components.strong, {\n        children: \"线段AB\"\n      }), \"到投影轴得到\", _jsx(_components.strong, {\n        children: \"投影JL\"\n      }), \"，我们可以将其看作\", _jsx(_components.strong, {\n        children: \"原点H与顶点B\"\n      }), \"投影得到\", _jsx(_components.strong, {\n        children: \"投影KL\"\n      }), \"、\", _jsx(_components.strong, {\n        children: \"原点H与顶点A\"\n      }), \"投影得到\", _jsx(_components.strong, {\n        children: \"投影KJ\"\n      }), \"，其他顶点类似——想要得到多边形的投影，只要得到\", _jsx(_components.strong, {\n        children: \"顶点投影到投影轴后相对于原点投影到投影轴的位置的“距离”（可正可负），相对最大最小值便可代表这个投影\"\n      }), \"。而这个相对值也甚至几乎是现成的：\", _jsx(_components.strong, {\n        children: \"原点到顶点的向量点乘边缘法向量便可（显然，为了结果有可比性，边缘法向量的大小必须固定，一般normalize大小为1）\"\n      }), \"，点乘的意义我相信大家也明白，就不赘述了。在比较两个多边形的投影时，其实比较的也是这样一个投影顶点相对投影原点的值。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"小小的经验\",\n      children: \"小小的经验\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果觉得上文概念混淆，那就对了！投影就是投影，是我们想到的最直观的比较方法。然而我们的目的只是\", _jsx(_components.strong, {\n        children: \"借助投影比较多边形是否重叠，而不是投影本身\"\n      }), \"，因此我们没有抽象出一个\", _jsx(_components.strong, {\n        children: \"直观的代表投影的数据结构\"\n      }), \"（比如用两个坐标表示？），而是\", _jsx(_components.strong, {\n        children: \"借助原点与投影性质抽象出一个尽管不是投影，却更容易比较的结构\"\n      }), \"，在我的代码里它是这样的：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-javascript\",\n      children: _jsxs(_components.code, {\n        className: \"language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"token comment\",\n          children: \"/* \\n    投影，\\n    用min和max来记录，\\n    因为实际上是顶点与原点构成的线段在轴上的投影，\\n    因为顶点的投影位置是固定的，\\n    所以比较时只需要考虑投影的“长度”（可以为负），\\n    min和max分别是一个多边形的所有顶点（与原点）投影长度的最小与最大值\\n*/\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token class-name\",\n          children: \"Projection\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"constructor\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsxs(_components.span, {\n          className: \"token parameter\",\n          children: [\"min\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" max\"]\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"this\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token property-access\",\n          children: \"min\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" min\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \";\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"this\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token property-access\",\n          children: \"max\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"=\"\n        }), \" max\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \";\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token function\",\n          children: \"overlaps\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token parameter\",\n          children: \"pro\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"token keyword control-flow\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"this\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token property-access\",\n          children: \"max\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"\u003e\"\n        }), \" pro\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token property-access\",\n          children: \"min\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"\u0026\u0026\"\n        }), \" pro\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token property-access\",\n          children: \"max\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token operator\",\n          children: \"\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"this\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \".\"\n        }), _jsx(_components.span, {\n          className: \"token property-access\",\n          children: \"min\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \";\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"成品\",\n      children: \"成品\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"俺的\", _jsx(_components.a, {\n        href: \"https://codepen.io/padfoot_07/full/pKyOYm\",\n        children: \"分离轴实现\"\n      }), \"，比较核心的部分就是\", _jsx(_components.code, {\n        children: \"Polygon对象的project、getNormals实现与Projection对象实现\"\n      })]\n    }), \"\\n\", _jsxs(\"p\", {\n      \"data-height\": \"265\",\n      \"data-theme-id\": \"0\",\n      \"data-slug-hash\": \"pKyOYm\",\n      \"data-default-tab\": \"js,result\",\n      \"data-user\": \"padfoot_07\",\n      \"data-embed-version\": \"2\",\n      \"data-pen-title\": \"分离轴-碰撞检测\",\n      class: \"codepen\",\n      children: [\"See the Pen \", _jsx(\"a\", {\n        href: \"https://codepen.io/padfoot_07/pen/pKyOYm/\",\n        children: \"分离轴-碰撞检测\"\n      }), \" by Zhouyi (\", _jsx(\"a\", {\n        href: \"https://codepen.io/padfoot_07\",\n        children: \"@padfoot_07\"\n      }), \") on \", _jsx(\"a\", {\n        href: \"https://codepen.io\",\n        children: \"CodePen\"\n      }), \".\"]\n    }), \"\\n\", _jsx(\"script\", {\n      async: true,\n      src: \"https://static.codepen.io/assets/embed/ei.js\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"今天是高考，又有很多人将要步入新一阶段的学习。感觉大家在学习中总是关注到很多很了不起的方面，却对于自己的生活方式没有认真的思考过呢。“赞美太阳！”虽是游戏中看似有些搞笑的台词，实际上对于个人来说，意味却是很认真的啊。（......我看你是传火传的活尸化严重了）\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"description":"之前在准备高考，没有更新；今天高考开始了，我决定不考了来更新嗯嗯【嗯？？？】......","usedCustomComponentNames":[]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"use-separation-for-impact-checking-in-irregular-shape"},"buildId":"31YAT_9sJuwKyhid7c4j7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>