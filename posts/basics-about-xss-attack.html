<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="《试图了解XSS注入，却发现了奇妙的基础问题！》"/><meta property="og:title" content="《试图了解XSS注入，却发现了奇妙的基础问题！》"/><meta property="og:description" content="啧，现在的轻小说起名真是浮夸【瞄】......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="color-scheme" content="dark light"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-165611dbf69200d4.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/332-751efa0ececa7b8e.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-2b4aeb585f50200f.js" defer=""></script><script src="/_next/static/FyxqUbHN51XEFT6ZDcrPF/_buildManifest.js" defer=""></script><script src="/_next/static/FyxqUbHN51XEFT6ZDcrPF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-9d615c10-0 gPcDhw"><div class="sc-868660b6-0 hptnUW"><div class="sc-bbc62a17-1 bGsVUC"><div class="sc-bbc62a17-0 dSoHmK"><a class="sc-bbc62a17-2 gGxkic" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-bbc62a17-2 gGxkic" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-bbc62a17-3 bMRVsR" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f71203c5-0 cEuFcK"><h1 class="sc-f71203c5-1 BdBtZ">LWDW!</h1><p class="sc-f71203c5-2 gXENPI">Learn the work from doing the work🍺</p></div></div><div class="sc-87e76b53-0 sc-77cf2bd4-0 hkJmkj dxfnCq"><div><div class="sc-ba46d312-0 hOKWax"><div class="sc-ba46d312-2 ibvPNw">《试图了解XSS注入，却发现了奇妙的基础问题！》</div><div class="sc-ba46d312-3 hcdRzS">Posted on <!-- -->2017-09-26</div></div></div></div><div class="sc-87e76b53-0 hkJmkj"><div><div class="sc-ba46d312-1 dmDrcr"><div class="sc-e9ca5221-0 czeavQ"><p>啧，现在的轻小说起名真是浮夸【瞄】</p>
<p>web安全，xss注入，blablabla......相关的博文看了不少，感觉相当单纯，不就是<code>&lt;script&gt;</code>嘛！转义嘛！结果自己尝试时又是喜闻乐见地发现，注入还没看多少，基础问题暴露一堆。</p>
<h2 id="注入入口-and-渲染方式">注入入口 and 渲染方式</h2>
<p>xss注入实现的攻击，总的来说是：</p>
<ol>
<li>通过某种方式将需要执行的代码注入到服务器所存储的数据中</li>
<li>其他客户端从服务器拿到数据渲染时，执行了注入其中的代码</li>
</ol>
<p>从某种意义上讲，这两步需要成功匹配，才能实现注入</p>
<h3 id="耿直注入">耿直注入</h3>
<p>最容易想到的注入入口就是<code>input</code>输入框，在这里就涉及到一个小知识点：<strong>input输入框中的内容(value属性值)是转义后的值</strong>。记好这一点嗯嗯。</p>
<p>确定从 input 进行注入后，需要考虑的就是客户端的渲染方式了——咱尝试了以下几种方式：</p>
<ol>
<li>首先很想当然的，想通过设置 dom元素的**<code>innerHTML</code>**属性进行渲染，然而…不行！<strong>innerHTML的确会非常耿直的把标签啥的直接当作节点插入，但是插入后不会执行<code>&lt;script&gt;内的内容</code></strong>，所以咱的脚本成功进入了客户端，却未被执行，可惜可惜。</li>
<li>通过**<code>appendChild()</code>**方法，是可以的！</li>
<li>Jquery的**<code>append()</code>**方法也是通过<code>innerHTML</code>渲染，但它会试图找到<code>script</code>标签，将其通过<code>eval()</code>执行，所以当然是可以的。要是用这种方法渲染用户可以决定的字段，简直是二五仔啊！</li>
</ol>
<h3 id="防范">防范？</h3>
<p>所以就像所有博文都会告诉你的防范方法：<strong>转义 <code>&lt;</code>和<code>&gt;</code></strong>，将其变为<strong>html字符实体</strong>，于是可喜可贺可喜可贺，这种方法可以毁灭性的摧毁用<code>&lt;script&gt;</code>字符串进行注入的想法，以上三种渲染方式都不会中招。</p>
<p>当然，道高一尺魔高一丈嘛，接下来博文就会告诉你，你可以用 <strong>unicode码</strong> 来表示  <strong><code>&lt;</code></strong> 和 <strong><code>&gt;</code></strong>，于是咱就迫不及待的在输入框中输入了伪装后的代码，然而它们却...直接被渲染出来了…没错，上面提到了，<strong>input输入框中的内容(value属性值)是转义后的值</strong>，你以为我是unicode码，其实我被已经转义啦（dio脸）！所以如果你想通过unicode码伪装，恐怕需要自己手动为请求数据赋值，比如从控制台手动请求接口。</p>
<h3 id="套路注入">套路注入</h3>
<p>假设我们已经成功用unicode码发出了请求，结果是......并没有卵用？嗯？这和博文上说的不一样啊。根据粗浅的研究，似乎是因为咱是node服务器啊，unicode码在node环境下已经被表示为符号形式了？然后直接被上文的防范措施干掉了。不过似乎对于php服务器，unicode码是可以保持它原本的样子，成功绕过上文的防范成功注入。</p>
<h3 id="套路防范">套路防范</h3>
<p>那么我们的解决方法是…没错，继续转义，这次要干掉的是 <strong><code>\</code></strong>,而在这里又意识到个很好笑的问题，因为咱不懂PHP，就试图在js中还原该场景。js中如何匹配字符串中的 <code>\</code> ？正则应该是 <code>/\\/g</code>，因为 <code>\</code>是本身就是用于转义特殊符号的嘛，那我们可以转义的字符串呢？是这样的<code>&quot;i want to replace \\&quot;</code>，这时才意识到这是个大乌龙啊！前面就说过了unicode码，如<code>&quot;\u003c&quot;</code>(<code>&lt;</code>)，一旦在node环境中作为字符串出现，会被直接解释为<code>&quot;&lt;&quot;</code>，根本轮不到咱插手啊【扑通】。总之，经过一通令人窒息的操作之后，才真切意识到：<strong>我们输入的字符，代码执行时所“看到”字符（手动比喻），和输出的字符</strong>，很多时候是不一样的。</p>
<hr/>
<p>咱大胆的假设！如果假设真的有除了咱以外的人看这篇水文，会不会有种偏题的感觉？xss都没讲完啊喂，什么img标签onerror注入url注入都没讲诶！emmmmme可是咱在学习时的确会遇到这种“偏题”的情况，咱正是试图用水文的形式记录下这诡异的思路，而不是总结一遍早有无数博文总结的要点【蛤你就是懒】，就是这样！溜了溜了【逃】</p></div></div></div></div><div class="sc-3304c032-0 fiBoCN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"basics-about-xss-attack","title":"《试图了解XSS注入，却发现了奇妙的基础问题！》","date":"2017-09-26","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    h3: \"h3\",\n    strong: \"strong\",\n    hr: \"hr\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"啧，现在的轻小说起名真是浮夸【瞄】\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"web安全，xss注入，blablabla......相关的博文看了不少，感觉相当单纯，不就是\", _jsx(_components.code, {\n        children: \"\u003cscript\u003e\"\n      }), \"嘛！转义嘛！结果自己尝试时又是喜闻乐见地发现，注入还没看多少，基础问题暴露一堆。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"注入入口-and-渲染方式\",\n      children: \"注入入口 and 渲染方式\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"xss注入实现的攻击，总的来说是：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"通过某种方式将需要执行的代码注入到服务器所存储的数据中\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"其他客户端从服务器拿到数据渲染时，执行了注入其中的代码\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"从某种意义上讲，这两步需要成功匹配，才能实现注入\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"耿直注入\",\n      children: \"耿直注入\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"最容易想到的注入入口就是\", _jsx(_components.code, {\n        children: \"input\"\n      }), \"输入框，在这里就涉及到一个小知识点：\", _jsx(_components.strong, {\n        children: \"input输入框中的内容(value属性值)是转义后的值\"\n      }), \"。记好这一点嗯嗯。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"确定从 input 进行注入后，需要考虑的就是客户端的渲染方式了——咱尝试了以下几种方式：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"首先很想当然的，想通过设置 dom元素的**\", _jsx(_components.code, {\n          children: \"innerHTML\"\n        }), \"**属性进行渲染，然而…不行！\", _jsxs(_components.strong, {\n          children: [\"innerHTML的确会非常耿直的把标签啥的直接当作节点插入，但是插入后不会执行\", _jsx(_components.code, {\n            children: \"\u003cscript\u003e内的内容\"\n          })]\n        }), \"，所以咱的脚本成功进入了客户端，却未被执行，可惜可惜。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"通过**\", _jsx(_components.code, {\n          children: \"appendChild()\"\n        }), \"**方法，是可以的！\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Jquery的**\", _jsx(_components.code, {\n          children: \"append()\"\n        }), \"**方法也是通过\", _jsx(_components.code, {\n          children: \"innerHTML\"\n        }), \"渲染，但它会试图找到\", _jsx(_components.code, {\n          children: \"script\"\n        }), \"标签，将其通过\", _jsx(_components.code, {\n          children: \"eval()\"\n        }), \"执行，所以当然是可以的。要是用这种方法渲染用户可以决定的字段，简直是二五仔啊！\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"防范\",\n      children: \"防范？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"所以就像所有博文都会告诉你的防范方法：\", _jsxs(_components.strong, {\n        children: [\"转义 \", _jsx(_components.code, {\n          children: \"\u003c\"\n        }), \"和\", _jsx(_components.code, {\n          children: \"\u003e\"\n        })]\n      }), \"，将其变为\", _jsx(_components.strong, {\n        children: \"html字符实体\"\n      }), \"，于是可喜可贺可喜可贺，这种方法可以毁灭性的摧毁用\", _jsx(_components.code, {\n        children: \"\u003cscript\u003e\"\n      }), \"字符串进行注入的想法，以上三种渲染方式都不会中招。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然，道高一尺魔高一丈嘛，接下来博文就会告诉你，你可以用 \", _jsx(_components.strong, {\n        children: \"unicode码\"\n      }), \" 来表示  \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"\u003c\"\n        })\n      }), \" 和 \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"\u003e\"\n        })\n      }), \"，于是咱就迫不及待的在输入框中输入了伪装后的代码，然而它们却...直接被渲染出来了…没错，上面提到了，\", _jsx(_components.strong, {\n        children: \"input输入框中的内容(value属性值)是转义后的值\"\n      }), \"，你以为我是unicode码，其实我被已经转义啦（dio脸）！所以如果你想通过unicode码伪装，恐怕需要自己手动为请求数据赋值，比如从控制台手动请求接口。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"套路注入\",\n      children: \"套路注入\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"假设我们已经成功用unicode码发出了请求，结果是......并没有卵用？嗯？这和博文上说的不一样啊。根据粗浅的研究，似乎是因为咱是node服务器啊，unicode码在node环境下已经被表示为符号形式了？然后直接被上文的防范措施干掉了。不过似乎对于php服务器，unicode码是可以保持它原本的样子，成功绕过上文的防范成功注入。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"套路防范\",\n      children: \"套路防范\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"那么我们的解决方法是…没错，继续转义，这次要干掉的是 \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"\\\\\"\n        })\n      }), \",而在这里又意识到个很好笑的问题，因为咱不懂PHP，就试图在js中还原该场景。js中如何匹配字符串中的 \", _jsx(_components.code, {\n        children: \"\\\\\"\n      }), \" ？正则应该是 \", _jsx(_components.code, {\n        children: \"/\\\\\\\\/g\"\n      }), \"，因为 \", _jsx(_components.code, {\n        children: \"\\\\\"\n      }), \"是本身就是用于转义特殊符号的嘛，那我们可以转义的字符串呢？是这样的\", _jsx(_components.code, {\n        children: \"\\\"i want to replace \\\\\\\\\\\"\"\n      }), \"，这时才意识到这是个大乌龙啊！前面就说过了unicode码，如\", _jsx(_components.code, {\n        children: \"\\\"\\\\u003c\\\"\"\n      }), \"(\", _jsx(_components.code, {\n        children: \"\u003c\"\n      }), \")，一旦在node环境中作为字符串出现，会被直接解释为\", _jsx(_components.code, {\n        children: \"\\\"\u003c\\\"\"\n      }), \"，根本轮不到咱插手啊【扑通】。总之，经过一通令人窒息的操作之后，才真切意识到：\", _jsx(_components.strong, {\n        children: \"我们输入的字符，代码执行时所“看到”字符（手动比喻），和输出的字符\"\n      }), \"，很多时候是不一样的。\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"咱大胆的假设！如果假设真的有除了咱以外的人看这篇水文，会不会有种偏题的感觉？xss都没讲完啊喂，什么img标签onerror注入url注入都没讲诶！emmmmme可是咱在学习时的确会遇到这种“偏题”的情况，咱正是试图用水文的形式记录下这诡异的思路，而不是总结一遍早有无数博文总结的要点【蛤你就是懒】，就是这样！溜了溜了【逃】\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"description":"啧，现在的轻小说起名真是浮夸【瞄】......","usedCustomComponentNames":[]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"basics-about-xss-attack"},"buildId":"FyxqUbHN51XEFT6ZDcrPF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>