<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="《试图了解XSS注入，却发现了奇妙的基础问题！》"/><meta property="og:title" content="《试图了解XSS注入，却发现了奇妙的基础问题！》"/><meta property="og:description" content="啧，现在的轻小说起名真是浮夸【瞄】......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f164db4954bac6ec.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/332-e879213584d084bf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-1001914fc6870d3d.js" defer=""></script><script src="/_next/static/YpEETIAkVEg0U66Qirl3Q/_buildManifest.js" defer=""></script><script src="/_next/static/YpEETIAkVEg0U66Qirl3Q/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-b711fa3b-0 dxGMRG"><div class="sc-7fa12c98-0 iqAzDm"><div class="sc-357ac6e1-1 blSmbb"><div class="sc-357ac6e1-0 fqUBXX"><a class="sc-357ac6e1-2 gfNIvm" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-357ac6e1-2 gfNIvm" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f5ce872-0 drvesR"><h1 class="sc-f5ce872-1 jPBPjm">LWDW!</h1><p class="sc-f5ce872-2 djaGsH">Learn the work from doing the work🍺</p></div></div><div class="sc-920e94b6-0 sc-20291786-0 cMfBpD eCERES"><div><div class="sc-32c5999b-0 iFBmZi"><div class="sc-32c5999b-2 fHkOeB">《试图了解XSS注入，却发现了奇妙的基础问题！》</div><div class="sc-32c5999b-3 deKveP">Posted on <!-- -->2017-09-26</div></div></div></div><div class="sc-920e94b6-0 cMfBpD"><div><div class="sc-32c5999b-1 fNXLto"><div class="sc-29ea8e37-0 bjoUyc"><div><html><head></head><body><p>啧，现在的轻小说起名真是浮夸【瞄】</p>
<p>web安全，xss注入，blablabla......相关的博文看了不少，感觉相当单纯，不就是<code>&#x3C;script></code>嘛！转义嘛！结果自己尝试时又是喜闻乐见地发现，注入还没看多少，基础问题暴露一堆。</p>
<h2 id="注入入口-and-渲染方式">注入入口 and 渲染方式</h2>
<p>xss注入实现的攻击，总的来说是：</p>
<ol>
<li>通过某种方式将需要执行的代码注入到服务器所存储的数据中</li>
<li>其他客户端从服务器拿到数据渲染时，执行了注入其中的代码</li>
</ol>
<p>从某种意义上讲，这两步需要成功匹配，才能实现注入</p>
<h3 id="耿直注入">耿直注入</h3>
<p>最容易想到的注入入口就是<code>input</code>输入框，在这里就涉及到一个小知识点：<strong>input输入框中的内容(value属性值)是转义后的值</strong>。记好这一点嗯嗯。</p>
<p>确定从 input 进行注入后，需要考虑的就是客户端的渲染方式了——咱尝试了以下几种方式：</p>
<ol>
<li>首先很想当然的，想通过设置 dom元素的**<code>innerHTML</code>**属性进行渲染，然而…不行！<strong>innerHTML的确会非常耿直的把标签啥的直接当作节点插入，但是插入后不会执行<code>&#x3C;script>内的内容</code></strong>，所以咱的脚本成功进入了客户端，却未被执行，可惜可惜。</li>
<li>通过**<code>appendChild()</code>**方法，是可以的！</li>
<li>Jquery的**<code>append()</code>**方法也是通过<code>innerHTML</code>渲染，但它会试图找到<code>script</code>标签，将其通过<code>eval()</code>执行，所以当然是可以的。要是用这种方法渲染用户可以决定的字段，简直是二五仔啊！</li>
</ol>
<h3 id="防范">防范？</h3>
<p>所以就像所有博文都会告诉你的防范方法：<strong>转义 <code>&#x3C;</code>和<code>></code></strong>，将其变为<strong>html字符实体</strong>，于是可喜可贺可喜可贺，这种方法可以毁灭性的摧毁用<code>&#x3C;script></code>字符串进行注入的想法，以上三种渲染方式都不会中招。</p>
<p>当然，道高一尺魔高一丈嘛，接下来博文就会告诉你，你可以用 <strong>unicode码</strong> 来表示  <strong>&#x3C;</strong> 和 <strong>></strong>，于是咱就迫不及待的在输入框中输入了伪装后的代码，然而它们却...直接被渲染出来了…没错，上面提到了，<strong>input输入框中的内容(value属性值)是转义后的值</strong>，你以为我是unicode码，其实我被已经转义啦（dio脸）！所以如果你想通过unicode码伪装，恐怕需要自己手动为请求数据赋值，比如从控制台手动请求接口。</p>
<h3 id="套路注入">套路注入</h3>
<p>假设我们已经成功用unicode码发出了请求，结果是......并没有卵用？嗯？这和博文上说的不一样啊。根据粗浅的研究，似乎是因为咱是node服务器啊，unicode码在node环境下已经被表示为符号形式了？然后直接被上文的防范措施干掉了。不过似乎对于php服务器，unicode码是可以保持它原本的样子，成功绕过上文的防范成功注入。</p>
<h3 id="套路防范">套路防范</h3>
<p>那么我们的解决方法是…没错，继续转义，这次要干掉的是 <strong><code>\</code></strong>,而在这里又意识到个很好笑的问题，因为咱不懂PHP，就试图在js中还原该场景。js中如何匹配字符串中的 <code>\</code> ？正则应该是 <code>/\\/g</code>，因为 <code>\</code>是本身就是用于转义特殊符号的嘛，那我们可以转义的字符串呢？是这样的<code>"i want to replace \\"</code>，这时才意识到这是个大乌龙啊！前面就说过了unicode码，如<code>"\u003c"</code>(<code>&#x3C;</code>)，一旦在node环境中作为字符串出现，会被直接解释为<code>"&#x3C;"</code>，根本轮不到咱插手啊【扑通】。总之，经过一通令人窒息的操作之后，才真切意识到：<strong>我们输入的字符，代码执行时所“看到”字符（手动比喻），和输出的字符</strong>，很多时候是不一样的。</p>
<hr>
<p>咱大胆的假设！如果假设真的有除了咱以外的人看这篇水文，会不会有种偏题的感觉？xss都没讲完啊喂，什么img标签onerror注入url注入都没讲诶！emmmmme可是咱在学习时的确会遇到这种“偏题”的情况，咱正是试图用水文的形式记录下这诡异的思路，而不是总结一遍早有无数博文总结的要点【蛤你就是懒】，就是这样！溜了溜了【逃】</p>
</body></html></div></div></div></div></div><div class="sc-bbd5e802-0 cbkQsN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"basics-about-xss-attack","title":"《试图了解XSS注入，却发现了奇妙的基础问题！》","date":"2017-09-26","htmlText":"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003cp\u003e啧，现在的轻小说起名真是浮夸【瞄】\u003c/p\u003e\n\u003cp\u003eweb安全，xss注入，blablabla......相关的博文看了不少，感觉相当单纯，不就是\u003ccode\u003e\u0026#x3C;script\u003e\u003c/code\u003e嘛！转义嘛！结果自己尝试时又是喜闻乐见地发现，注入还没看多少，基础问题暴露一堆。\u003c/p\u003e\n\u003ch2 id=\"注入入口-and-渲染方式\"\u003e注入入口 and 渲染方式\u003c/h2\u003e\n\u003cp\u003exss注入实现的攻击，总的来说是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过某种方式将需要执行的代码注入到服务器所存储的数据中\u003c/li\u003e\n\u003cli\u003e其他客户端从服务器拿到数据渲染时，执行了注入其中的代码\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e从某种意义上讲，这两步需要成功匹配，才能实现注入\u003c/p\u003e\n\u003ch3 id=\"耿直注入\"\u003e耿直注入\u003c/h3\u003e\n\u003cp\u003e最容易想到的注入入口就是\u003ccode\u003einput\u003c/code\u003e输入框，在这里就涉及到一个小知识点：\u003cstrong\u003einput输入框中的内容(value属性值)是转义后的值\u003c/strong\u003e。记好这一点嗯嗯。\u003c/p\u003e\n\u003cp\u003e确定从 input 进行注入后，需要考虑的就是客户端的渲染方式了——咱尝试了以下几种方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先很想当然的，想通过设置 dom元素的**\u003ccode\u003einnerHTML\u003c/code\u003e**属性进行渲染，然而…不行！\u003cstrong\u003einnerHTML的确会非常耿直的把标签啥的直接当作节点插入，但是插入后不会执行\u003ccode\u003e\u0026#x3C;script\u003e内的内容\u003c/code\u003e\u003c/strong\u003e，所以咱的脚本成功进入了客户端，却未被执行，可惜可惜。\u003c/li\u003e\n\u003cli\u003e通过**\u003ccode\u003eappendChild()\u003c/code\u003e**方法，是可以的！\u003c/li\u003e\n\u003cli\u003eJquery的**\u003ccode\u003eappend()\u003c/code\u003e**方法也是通过\u003ccode\u003einnerHTML\u003c/code\u003e渲染，但它会试图找到\u003ccode\u003escript\u003c/code\u003e标签，将其通过\u003ccode\u003eeval()\u003c/code\u003e执行，所以当然是可以的。要是用这种方法渲染用户可以决定的字段，简直是二五仔啊！\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"防范\"\u003e防范？\u003c/h3\u003e\n\u003cp\u003e所以就像所有博文都会告诉你的防范方法：\u003cstrong\u003e转义 \u003ccode\u003e\u0026#x3C;\u003c/code\u003e和\u003ccode\u003e\u003e\u003c/code\u003e\u003c/strong\u003e，将其变为\u003cstrong\u003ehtml字符实体\u003c/strong\u003e，于是可喜可贺可喜可贺，这种方法可以毁灭性的摧毁用\u003ccode\u003e\u0026#x3C;script\u003e\u003c/code\u003e字符串进行注入的想法，以上三种渲染方式都不会中招。\u003c/p\u003e\n\u003cp\u003e当然，道高一尺魔高一丈嘛，接下来博文就会告诉你，你可以用 \u003cstrong\u003eunicode码\u003c/strong\u003e 来表示  \u003cstrong\u003e\u0026#x3C;\u003c/strong\u003e 和 \u003cstrong\u003e\u003e\u003c/strong\u003e，于是咱就迫不及待的在输入框中输入了伪装后的代码，然而它们却...直接被渲染出来了…没错，上面提到了，\u003cstrong\u003einput输入框中的内容(value属性值)是转义后的值\u003c/strong\u003e，你以为我是unicode码，其实我被已经转义啦（dio脸）！所以如果你想通过unicode码伪装，恐怕需要自己手动为请求数据赋值，比如从控制台手动请求接口。\u003c/p\u003e\n\u003ch3 id=\"套路注入\"\u003e套路注入\u003c/h3\u003e\n\u003cp\u003e假设我们已经成功用unicode码发出了请求，结果是......并没有卵用？嗯？这和博文上说的不一样啊。根据粗浅的研究，似乎是因为咱是node服务器啊，unicode码在node环境下已经被表示为符号形式了？然后直接被上文的防范措施干掉了。不过似乎对于php服务器，unicode码是可以保持它原本的样子，成功绕过上文的防范成功注入。\u003c/p\u003e\n\u003ch3 id=\"套路防范\"\u003e套路防范\u003c/h3\u003e\n\u003cp\u003e那么我们的解决方法是…没错，继续转义，这次要干掉的是 \u003cstrong\u003e\u003ccode\u003e\\\u003c/code\u003e\u003c/strong\u003e,而在这里又意识到个很好笑的问题，因为咱不懂PHP，就试图在js中还原该场景。js中如何匹配字符串中的 \u003ccode\u003e\\\u003c/code\u003e ？正则应该是 \u003ccode\u003e/\\\\/g\u003c/code\u003e，因为 \u003ccode\u003e\\\u003c/code\u003e是本身就是用于转义特殊符号的嘛，那我们可以转义的字符串呢？是这样的\u003ccode\u003e\"i want to replace \\\\\"\u003c/code\u003e，这时才意识到这是个大乌龙啊！前面就说过了unicode码，如\u003ccode\u003e\"\\u003c\"\u003c/code\u003e(\u003ccode\u003e\u0026#x3C;\u003c/code\u003e)，一旦在node环境中作为字符串出现，会被直接解释为\u003ccode\u003e\"\u0026#x3C;\"\u003c/code\u003e，根本轮不到咱插手啊【扑通】。总之，经过一通令人窒息的操作之后，才真切意识到：\u003cstrong\u003e我们输入的字符，代码执行时所“看到”字符（手动比喻），和输出的字符\u003c/strong\u003e，很多时候是不一样的。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e咱大胆的假设！如果假设真的有除了咱以外的人看这篇水文，会不会有种偏题的感觉？xss都没讲完啊喂，什么img标签onerror注入url注入都没讲诶！emmmmme可是咱在学习时的确会遇到这种“偏题”的情况，咱正是试图用水文的形式记录下这诡异的思路，而不是总结一遍早有无数博文总结的要点【蛤你就是懒】，就是这样！溜了溜了【逃】\u003c/p\u003e\n\u003c/body\u003e\u003c/html\u003e","description":"啧，现在的轻小说起名真是浮夸【瞄】......"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"basics-about-xss-attack"},"buildId":"YpEETIAkVEg0U66Qirl3Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>