<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>LWDW!</title><meta name="description" content="弹一弹#2 方块与圆の碰撞物语"/><meta property="og:title" content="弹一弹#2 方块与圆の碰撞物语"/><meta property="og:description" content="编译原理好鸡儿难，课设真尼玛烦，俺现在只想摸鱼 \_(┐「ε:)\_......"/><meta name="next-head-count" content="6"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#ffffff"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="theme-color" content="#000"/><meta property="og:type" content="website"/><meta property="og:image" content="https://s2.loli.net/2023/01/18/42YTZxzePtR7jy9.png"/><meta property="og:url" content="https://b-sirius.github.io"/><link rel="preload" href="/_next/static/css/aef510c8abf24c2c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aef510c8abf24c2c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b51a0fb142b75fa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b51a0fb142b75fa0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f164db4954bac6ec.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-673a4fae4a27af6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0da236044dc4e5fc.js" defer=""></script><script src="/_next/static/chunks/664-1b4479b4462ded63.js" defer=""></script><script src="/_next/static/chunks/332-e879213584d084bf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-1001914fc6870d3d.js" defer=""></script><script src="/_next/static/a9qbsu3QIR-E7ZeJZ2det/_buildManifest.js" defer=""></script><script src="/_next/static/a9qbsu3QIR-E7ZeJZ2det/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-b711fa3b-0 dxGMRG"><div class="sc-7fa12c98-0 iqAzDm"><div class="sc-357ac6e1-1 blSmbb"><div class="sc-357ac6e1-0 fqUBXX"><a class="sc-357ac6e1-2 gfNIvm" href="/">[<!-- -->Home<!-- -->]</a><a class="sc-357ac6e1-2 gfNIvm" href="/posts">[<!-- -->Posts<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://github.com/B-sirius">[<!-- -->Github<!-- -->]</a><a class="sc-357ac6e1-3 eNeEmH" rel="noopener noreferrer" target="_blank" href="https://b-sirius.github.io/rss.xml">[<!-- -->RSS<!-- -->]</a></div><div class="sc-f5ce872-0 drvesR"><h1 class="sc-f5ce872-1 jPBPjm">LWDW!</h1><p class="sc-f5ce872-2 djaGsH">Learn the work from doing the work🍺</p></div></div><div class="sc-920e94b6-0 sc-20291786-0 cMfBpD eCERES"><div><div class="sc-32c5999b-0 iFBmZi"><div class="sc-32c5999b-2 fHkOeB">弹一弹#2 方块与圆の碰撞物语</div><div class="sc-32c5999b-3 deKveP">Posted on <!-- -->2018-05-03</div></div></div></div><div class="sc-920e94b6-0 cMfBpD"><div><div class="sc-32c5999b-1 fNXLto"><div class="sc-29ea8e37-0 bjoUyc"><div><html><head></head><body><p>编译原理好鸡儿难，课设真尼玛烦，俺现在只想摸鱼 _(┐「ε:)_</p>
<hr>
<h2 id="前言">前言</h2>
<p>对于两个物体之间的碰撞检测，依据两个物体本身属性的不同，所采取的策略也不尽相同。简单的来说可以分为3大类：</p>
<ol>
<li>依据每一帧中，几何图形的重合来检测</li>
<li>基于像素、地图格子来检测</li>
<li>基于速度矢量与相应判别条件来检测</li>
</ol>
<p>在弹一弹的例子中，第一种应该是首要的检测方式，后面两种如果俺开心再写吧【滑稽】</p>
<p>而在第一种中，又有几种不同的情形需要采取不同策略对待：</p>
<ol>
<li>圆-圆</li>
<li>无旋转矩形-无旋转矩形</li>
<li>圆-矩形（可有旋转）</li>
<li>任意多边形</li>
</ol>
<p>其中1和2都太过耿直，在此不做说明。本水文着重讨论第3种情形，第4种会更的嗯，俺有骗过你么 （’へ’）</p>
<h2 id="圆--无旋转方块儿">圆 &#x26; 无旋转方块儿</h2>
<p>我们要解决的问题，本质上就是要知道圆与矩形有无“接触”——而有了圆-圆检测的经验后，不难想到，我们要做的就是找到<strong>矩形上离圆最近的点</strong>，通过这一点到圆心的距离与圆的半径之间的比较，就能确定圆与矩形是否接触：</p>
<p>图片来源：<a href="https://aotu.io/notes/2017/02/16/2d-collision-detection/" target="_blank" rel="nofollow">凹凸实验室</a></p>
<p><img src="https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-1.png" alt="情形2"></p>
<p><img src="https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-2.png" alt="情形1"></p>
<p><img src="https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-3.png" alt="情形1"></p>
<p>不难看出这个最近点在x轴、y轴与圆心之间的关系，可以参考下面这个demo：</p>
<p data-height="265" data-theme-id="0" data-slug-hash="YLpBZM" data-default-tab="js,result" data-user="padfoot_07" data-embed-version="2" data-pen-title="rect&#x26;ball" class="codepen">See the Pen <a href="https://codepen.io/padfoot_07/pen/YLpBZM/" target="_blank" rel="nofollow">rect&#x26;ball</a> by Zhouyi (<a href="https://codepen.io/padfoot_07" target="_blank" rel="nofollow">@padfoot_07</a>) on <a href="https://codepen.io" target="_blank" rel="nofollow">CodePen</a>.</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
<h2 id="圆--旋转方块儿">圆 &#x26; 旋转方块儿</h2>
<p>如果矩形旋转了a度，只需要<strong>以矩形中心为旋转中心，旋转画布-a度</strong>，我们就又回到了上面一种无旋转情形！</p>
<p>换而言之，我们需要额外做的，就是计算<strong>旋转后的圆心</strong>。那么首先推导一下某个点绕原点旋转一定角度后的坐标：</p>
<p>证明来源：<a href="https://aotu.io/notes/2017/02/16/2d-collision-detection/" target="_blank" rel="nofollow">凹凸实验室</a></p>
<p><img src="https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-4.png" alt="原点旋转"></p>
<p>A为旋转前，B为原点，C为旋转后，r为半径，则</p>
<ol>
<li>设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)</li>
<li>由于 |AB| 与 |CB| 相等（即长度），且
<ul>
<li>|AB| = y/sin(δ) = x / cos(δ)</li>
<li>|CB| = d/sin(δ + β) = c / cos(δ + β)</li>
</ul>
</li>
<li>半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)</li>
<li>三角函数两角和差公式：
<ul>
<li>sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)</li>
<li>cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)</li>
</ul>
</li>
<li>得出旋转后的坐标
<ul>
<li>c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)</li>
<li>d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)</li>
</ul>
</li>
</ol>
<p>那么对于旋转中心 (centerX, centerY) ，其实只要做一个坐标轴平移的工作：</p>
<p><img src="https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-5.png" alt="绕某点旋转"></p>
<pre class="language-javascript"><code class="language-javascript">x’ <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>β<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>cx – centerX<span class="token punctuation">)</span> – <span class="token function">sin</span><span class="token punctuation">(</span>β<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>cy – centerY<span class="token punctuation">)</span> <span class="token operator">+</span> centerX
y’ <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>β<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>cx – centerX<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">cos</span><span class="token punctuation">(</span>β<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>cy – centerY<span class="token punctuation">)</span> <span class="token operator">+</span> centerY
</code></pre>
<p>以上就是我们需要的旋转公式。</p>
<p>下面这个demo中应用了上述理论，透明度较低的是旋转后的图形：</p>
<p data-height="265" data-theme-id="0" data-slug-hash="rvmKKj" data-default-tab="js,result" data-user="padfoot_07" data-embed-version="2" data-pen-title="rotatedRect&#x26;ball" class="codepen">See the Pen <a href="https://codepen.io/padfoot_07/pen/rvmKKj/" target="_blank" rel="nofollow">rotatedRect&#x26;ball</a> by Zhouyi (<a href="https://codepen.io/padfoot_07" target="_blank" rel="nofollow">@padfoot_07</a>) on <a href="https://codepen.io" target="_blank" rel="nofollow">CodePen</a>.</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
<hr>
<p>好了不多说了，我只想看下一集小英雄，再见了您！</p>
</body></html></div></div></div></div></div><div class="sc-bbd5e802-0 cbkQsN"><div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"impact-checking-between-square-and-circle","title":"弹一弹#2 方块与圆の碰撞物语","date":"2018-05-03","htmlText":"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003cp\u003e编译原理好鸡儿难，课设真尼玛烦，俺现在只想摸鱼 _(┐「ε:)_\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e对于两个物体之间的碰撞检测，依据两个物体本身属性的不同，所采取的策略也不尽相同。简单的来说可以分为3大类：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e依据每一帧中，几何图形的重合来检测\u003c/li\u003e\n\u003cli\u003e基于像素、地图格子来检测\u003c/li\u003e\n\u003cli\u003e基于速度矢量与相应判别条件来检测\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在弹一弹的例子中，第一种应该是首要的检测方式，后面两种如果俺开心再写吧【滑稽】\u003c/p\u003e\n\u003cp\u003e而在第一种中，又有几种不同的情形需要采取不同策略对待：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e圆-圆\u003c/li\u003e\n\u003cli\u003e无旋转矩形-无旋转矩形\u003c/li\u003e\n\u003cli\u003e圆-矩形（可有旋转）\u003c/li\u003e\n\u003cli\u003e任意多边形\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e其中1和2都太过耿直，在此不做说明。本水文着重讨论第3种情形，第4种会更的嗯，俺有骗过你么 （’へ’）\u003c/p\u003e\n\u003ch2 id=\"圆--无旋转方块儿\"\u003e圆 \u0026#x26; 无旋转方块儿\u003c/h2\u003e\n\u003cp\u003e我们要解决的问题，本质上就是要知道圆与矩形有无“接触”——而有了圆-圆检测的经验后，不难想到，我们要做的就是找到\u003cstrong\u003e矩形上离圆最近的点\u003c/strong\u003e，通过这一点到圆心的距离与圆的半径之间的比较，就能确定圆与矩形是否接触：\u003c/p\u003e\n\u003cp\u003e图片来源：\u003ca href=\"https://aotu.io/notes/2017/02/16/2d-collision-detection/\" target=\"_blank\" rel=\"nofollow\"\u003e凹凸实验室\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-1.png\" alt=\"情形2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-2.png\" alt=\"情形1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-3.png\" alt=\"情形1\"\u003e\u003c/p\u003e\n\u003cp\u003e不难看出这个最近点在x轴、y轴与圆心之间的关系，可以参考下面这个demo：\u003c/p\u003e\n\u003cp data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"YLpBZM\" data-default-tab=\"js,result\" data-user=\"padfoot_07\" data-embed-version=\"2\" data-pen-title=\"rect\u0026#x26;ball\" class=\"codepen\"\u003eSee the Pen \u003ca href=\"https://codepen.io/padfoot_07/pen/YLpBZM/\" target=\"_blank\" rel=\"nofollow\"\u003erect\u0026#x26;ball\u003c/a\u003e by Zhouyi (\u003ca href=\"https://codepen.io/padfoot_07\" target=\"_blank\" rel=\"nofollow\"\u003e@padfoot_07\u003c/a\u003e) on \u003ca href=\"https://codepen.io\" target=\"_blank\" rel=\"nofollow\"\u003eCodePen\u003c/a\u003e.\u003c/p\u003e\n\u003cscript async src=\"https://static.codepen.io/assets/embed/ei.js\"\u003e\u003c/script\u003e\n\u003ch2 id=\"圆--旋转方块儿\"\u003e圆 \u0026#x26; 旋转方块儿\u003c/h2\u003e\n\u003cp\u003e如果矩形旋转了a度，只需要\u003cstrong\u003e以矩形中心为旋转中心，旋转画布-a度\u003c/strong\u003e，我们就又回到了上面一种无旋转情形！\u003c/p\u003e\n\u003cp\u003e换而言之，我们需要额外做的，就是计算\u003cstrong\u003e旋转后的圆心\u003c/strong\u003e。那么首先推导一下某个点绕原点旋转一定角度后的坐标：\u003c/p\u003e\n\u003cp\u003e证明来源：\u003ca href=\"https://aotu.io/notes/2017/02/16/2d-collision-detection/\" target=\"_blank\" rel=\"nofollow\"\u003e凹凸实验室\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-4.png\" alt=\"原点旋转\"\u003e\u003c/p\u003e\n\u003cp\u003eA为旋转前，B为原点，C为旋转后，r为半径，则\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)\u003c/li\u003e\n\u003cli\u003e由于 |AB| 与 |CB| 相等（即长度），且\n\u003cul\u003e\n\u003cli\u003e|AB| = y/sin(δ) = x / cos(δ)\u003c/li\u003e\n\u003cli\u003e|CB| = d/sin(δ + β) = c / cos(δ + β)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)\u003c/li\u003e\n\u003cli\u003e三角函数两角和差公式：\n\u003cul\u003e\n\u003cli\u003esin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)\u003c/li\u003e\n\u003cli\u003ecos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e得出旋转后的坐标\n\u003cul\u003e\n\u003cli\u003ec = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)\u003c/li\u003e\n\u003cli\u003ed = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e那么对于旋转中心 (centerX, centerY) ，其实只要做一个坐标轴平移的工作：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://hukua-blog.oss-cn-beijing.aliyuncs.com/markdown-imgs/rect%26circle-5.png\" alt=\"绕某点旋转\"\u003e\u003c/p\u003e\n\u003cpre class=\"language-javascript\"\u003e\u003ccode class=\"language-javascript\"\u003ex’ \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003ecos\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eβ\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ecx – centerX\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e – \u003cspan class=\"token function\"\u003esin\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eβ\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ecy – centerY\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e centerX\ny’ \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003esin\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eβ\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ecx – centerX\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e \u003cspan class=\"token function\"\u003ecos\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eβ\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ecy – centerY\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e centerY\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以上就是我们需要的旋转公式。\u003c/p\u003e\n\u003cp\u003e下面这个demo中应用了上述理论，透明度较低的是旋转后的图形：\u003c/p\u003e\n\u003cp data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"rvmKKj\" data-default-tab=\"js,result\" data-user=\"padfoot_07\" data-embed-version=\"2\" data-pen-title=\"rotatedRect\u0026#x26;ball\" class=\"codepen\"\u003eSee the Pen \u003ca href=\"https://codepen.io/padfoot_07/pen/rvmKKj/\" target=\"_blank\" rel=\"nofollow\"\u003erotatedRect\u0026#x26;ball\u003c/a\u003e by Zhouyi (\u003ca href=\"https://codepen.io/padfoot_07\" target=\"_blank\" rel=\"nofollow\"\u003e@padfoot_07\u003c/a\u003e) on \u003ca href=\"https://codepen.io\" target=\"_blank\" rel=\"nofollow\"\u003eCodePen\u003c/a\u003e.\u003c/p\u003e\n\u003cscript async src=\"https://static.codepen.io/assets/embed/ei.js\"\u003e\u003c/script\u003e\n\u003chr\u003e\n\u003cp\u003e好了不多说了，我只想看下一集小英雄，再见了您！\u003c/p\u003e\n\u003c/body\u003e\u003c/html\u003e","description":"编译原理好鸡儿难，课设真尼玛烦，俺现在只想摸鱼 \\_(┐「ε:)\\_......"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"impact-checking-between-square-and-circle"},"buildId":"a9qbsu3QIR-E7ZeJZ2det","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>